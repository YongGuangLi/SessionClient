/**
 * Autogenerated by Thrift Compiler (0.13.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "rpc_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>



int _kTSProtocolVersionValues[] = {
  TSProtocolVersion::IOTDB_SERVICE_PROTOCOL_V1,
  TSProtocolVersion::IOTDB_SERVICE_PROTOCOL_V2,
  TSProtocolVersion::IOTDB_SERVICE_PROTOCOL_V3
};
const char* _kTSProtocolVersionNames[] = {
  "IOTDB_SERVICE_PROTOCOL_V1",
  "IOTDB_SERVICE_PROTOCOL_V2",
  "IOTDB_SERVICE_PROTOCOL_V3"
};
const std::map<int, const char*> _TSProtocolVersion_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kTSProtocolVersionValues, _kTSProtocolVersionNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const TSProtocolVersion::type& val) {
  std::map<int, const char*>::const_iterator it = _TSProtocolVersion_VALUES_TO_NAMES.find(val);
  if (it != _TSProtocolVersion_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const TSProtocolVersion::type& val) {
  std::map<int, const char*>::const_iterator it = _TSProtocolVersion_VALUES_TO_NAMES.find(val);
  if (it != _TSProtocolVersion_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}


EndPoint::~EndPoint() noexcept {
}


void EndPoint::__set_ip(const std::string& val) {
  this->ip = val;
}

void EndPoint::__set_port(const int32_t val) {
  this->port = val;
}
std::ostream& operator<<(std::ostream& out, const EndPoint& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t EndPoint::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_ip = false;
  bool isset_port = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->ip);
          isset_ip = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->port);
          isset_port = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_ip)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_port)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t EndPoint::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("EndPoint");

  xfer += oprot->writeFieldBegin("ip", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->ip);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("port", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->port);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(EndPoint &a, EndPoint &b) {
  using ::std::swap;
  swap(a.ip, b.ip);
  swap(a.port, b.port);
}

EndPoint::EndPoint(const EndPoint& other0) {
  ip = other0.ip;
  port = other0.port;
}
EndPoint& EndPoint::operator=(const EndPoint& other1) {
  ip = other1.ip;
  port = other1.port;
  return *this;
}
void EndPoint::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "EndPoint(";
  out << "ip=" << to_string(ip);
  out << ", " << "port=" << to_string(port);
  out << ")";
}


TSStatus::~TSStatus() noexcept {
}


void TSStatus::__set_code(const int32_t val) {
  this->code = val;
}

void TSStatus::__set_message(const std::string& val) {
  this->message = val;
__isset.message = true;
}

void TSStatus::__set_subStatus(const std::vector<TSStatus> & val) {
  this->subStatus = val;
__isset.subStatus = true;
}

void TSStatus::__set_redirectNode(const EndPoint& val) {
  this->redirectNode = val;
__isset.redirectNode = true;
}
std::ostream& operator<<(std::ostream& out, const TSStatus& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TSStatus::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_code = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->code);
          isset_code = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->message);
          this->__isset.message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->subStatus.clear();
            uint32_t _size2;
            ::apache::thrift::protocol::TType _etype5;
            xfer += iprot->readListBegin(_etype5, _size2);
            this->subStatus.resize(_size2);
            uint32_t _i6;
            for (_i6 = 0; _i6 < _size2; ++_i6)
            {
              xfer += this->subStatus[_i6].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.subStatus = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->redirectNode.read(iprot);
          this->__isset.redirectNode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_code)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TSStatus::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TSStatus");

  xfer += oprot->writeFieldBegin("code", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->code);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.message) {
    xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->message);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.subStatus) {
    xfer += oprot->writeFieldBegin("subStatus", ::apache::thrift::protocol::T_LIST, 3);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->subStatus.size()));
      std::vector<TSStatus> ::const_iterator _iter7;
      for (_iter7 = this->subStatus.begin(); _iter7 != this->subStatus.end(); ++_iter7)
      {
        xfer += (*_iter7).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.redirectNode) {
    xfer += oprot->writeFieldBegin("redirectNode", ::apache::thrift::protocol::T_STRUCT, 4);
    xfer += this->redirectNode.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TSStatus &a, TSStatus &b) {
  using ::std::swap;
  swap(a.code, b.code);
  swap(a.message, b.message);
  swap(a.subStatus, b.subStatus);
  swap(a.redirectNode, b.redirectNode);
  swap(a.__isset, b.__isset);
}

TSStatus::TSStatus(const TSStatus& other8) {
  code = other8.code;
  message = other8.message;
  subStatus = other8.subStatus;
  redirectNode = other8.redirectNode;
  __isset = other8.__isset;
}
TSStatus& TSStatus::operator=(const TSStatus& other9) {
  code = other9.code;
  message = other9.message;
  subStatus = other9.subStatus;
  redirectNode = other9.redirectNode;
  __isset = other9.__isset;
  return *this;
}
void TSStatus::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TSStatus(";
  out << "code=" << to_string(code);
  out << ", " << "message="; (__isset.message ? (out << to_string(message)) : (out << "<null>"));
  out << ", " << "subStatus="; (__isset.subStatus ? (out << to_string(subStatus)) : (out << "<null>"));
  out << ", " << "redirectNode="; (__isset.redirectNode ? (out << to_string(redirectNode)) : (out << "<null>"));
  out << ")";
}


TSQueryDataSet::~TSQueryDataSet() noexcept {
}


void TSQueryDataSet::__set_time(const std::string& val) {
  this->time = val;
}

void TSQueryDataSet::__set_valueList(const std::vector<std::string> & val) {
  this->valueList = val;
}

void TSQueryDataSet::__set_bitmapList(const std::vector<std::string> & val) {
  this->bitmapList = val;
}
std::ostream& operator<<(std::ostream& out, const TSQueryDataSet& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TSQueryDataSet::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_time = false;
  bool isset_valueList = false;
  bool isset_bitmapList = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->time);
          isset_time = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->valueList.clear();
            uint32_t _size10;
            ::apache::thrift::protocol::TType _etype13;
            xfer += iprot->readListBegin(_etype13, _size10);
            this->valueList.resize(_size10);
            uint32_t _i14;
            for (_i14 = 0; _i14 < _size10; ++_i14)
            {
              xfer += iprot->readBinary(this->valueList[_i14]);
            }
            xfer += iprot->readListEnd();
          }
          isset_valueList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->bitmapList.clear();
            uint32_t _size15;
            ::apache::thrift::protocol::TType _etype18;
            xfer += iprot->readListBegin(_etype18, _size15);
            this->bitmapList.resize(_size15);
            uint32_t _i19;
            for (_i19 = 0; _i19 < _size15; ++_i19)
            {
              xfer += iprot->readBinary(this->bitmapList[_i19]);
            }
            xfer += iprot->readListEnd();
          }
          isset_bitmapList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_time)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_valueList)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_bitmapList)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TSQueryDataSet::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TSQueryDataSet");

  xfer += oprot->writeFieldBegin("time", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->time);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("valueList", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->valueList.size()));
    std::vector<std::string> ::const_iterator _iter20;
    for (_iter20 = this->valueList.begin(); _iter20 != this->valueList.end(); ++_iter20)
    {
      xfer += oprot->writeBinary((*_iter20));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bitmapList", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->bitmapList.size()));
    std::vector<std::string> ::const_iterator _iter21;
    for (_iter21 = this->bitmapList.begin(); _iter21 != this->bitmapList.end(); ++_iter21)
    {
      xfer += oprot->writeBinary((*_iter21));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TSQueryDataSet &a, TSQueryDataSet &b) {
  using ::std::swap;
  swap(a.time, b.time);
  swap(a.valueList, b.valueList);
  swap(a.bitmapList, b.bitmapList);
}

TSQueryDataSet::TSQueryDataSet(const TSQueryDataSet& other22) {
  time = other22.time;
  valueList = other22.valueList;
  bitmapList = other22.bitmapList;
}
TSQueryDataSet& TSQueryDataSet::operator=(const TSQueryDataSet& other23) {
  time = other23.time;
  valueList = other23.valueList;
  bitmapList = other23.bitmapList;
  return *this;
}
void TSQueryDataSet::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TSQueryDataSet(";
  out << "time=" << to_string(time);
  out << ", " << "valueList=" << to_string(valueList);
  out << ", " << "bitmapList=" << to_string(bitmapList);
  out << ")";
}


TSQueryNonAlignDataSet::~TSQueryNonAlignDataSet() noexcept {
}


void TSQueryNonAlignDataSet::__set_timeList(const std::vector<std::string> & val) {
  this->timeList = val;
}

void TSQueryNonAlignDataSet::__set_valueList(const std::vector<std::string> & val) {
  this->valueList = val;
}
std::ostream& operator<<(std::ostream& out, const TSQueryNonAlignDataSet& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TSQueryNonAlignDataSet::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_timeList = false;
  bool isset_valueList = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->timeList.clear();
            uint32_t _size24;
            ::apache::thrift::protocol::TType _etype27;
            xfer += iprot->readListBegin(_etype27, _size24);
            this->timeList.resize(_size24);
            uint32_t _i28;
            for (_i28 = 0; _i28 < _size24; ++_i28)
            {
              xfer += iprot->readBinary(this->timeList[_i28]);
            }
            xfer += iprot->readListEnd();
          }
          isset_timeList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->valueList.clear();
            uint32_t _size29;
            ::apache::thrift::protocol::TType _etype32;
            xfer += iprot->readListBegin(_etype32, _size29);
            this->valueList.resize(_size29);
            uint32_t _i33;
            for (_i33 = 0; _i33 < _size29; ++_i33)
            {
              xfer += iprot->readBinary(this->valueList[_i33]);
            }
            xfer += iprot->readListEnd();
          }
          isset_valueList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_timeList)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_valueList)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TSQueryNonAlignDataSet::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TSQueryNonAlignDataSet");

  xfer += oprot->writeFieldBegin("timeList", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->timeList.size()));
    std::vector<std::string> ::const_iterator _iter34;
    for (_iter34 = this->timeList.begin(); _iter34 != this->timeList.end(); ++_iter34)
    {
      xfer += oprot->writeBinary((*_iter34));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("valueList", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->valueList.size()));
    std::vector<std::string> ::const_iterator _iter35;
    for (_iter35 = this->valueList.begin(); _iter35 != this->valueList.end(); ++_iter35)
    {
      xfer += oprot->writeBinary((*_iter35));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TSQueryNonAlignDataSet &a, TSQueryNonAlignDataSet &b) {
  using ::std::swap;
  swap(a.timeList, b.timeList);
  swap(a.valueList, b.valueList);
}

TSQueryNonAlignDataSet::TSQueryNonAlignDataSet(const TSQueryNonAlignDataSet& other36) {
  timeList = other36.timeList;
  valueList = other36.valueList;
}
TSQueryNonAlignDataSet& TSQueryNonAlignDataSet::operator=(const TSQueryNonAlignDataSet& other37) {
  timeList = other37.timeList;
  valueList = other37.valueList;
  return *this;
}
void TSQueryNonAlignDataSet::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TSQueryNonAlignDataSet(";
  out << "timeList=" << to_string(timeList);
  out << ", " << "valueList=" << to_string(valueList);
  out << ")";
}


TSExecuteStatementResp::~TSExecuteStatementResp() noexcept {
}


void TSExecuteStatementResp::__set_status(const TSStatus& val) {
  this->status = val;
}

void TSExecuteStatementResp::__set_queryId(const int64_t val) {
  this->queryId = val;
__isset.queryId = true;
}

void TSExecuteStatementResp::__set_columns(const std::vector<std::string> & val) {
  this->columns = val;
__isset.columns = true;
}

void TSExecuteStatementResp::__set_operationType(const std::string& val) {
  this->operationType = val;
__isset.operationType = true;
}

void TSExecuteStatementResp::__set_ignoreTimeStamp(const bool val) {
  this->ignoreTimeStamp = val;
__isset.ignoreTimeStamp = true;
}

void TSExecuteStatementResp::__set_dataTypeList(const std::vector<std::string> & val) {
  this->dataTypeList = val;
__isset.dataTypeList = true;
}

void TSExecuteStatementResp::__set_queryDataSet(const TSQueryDataSet& val) {
  this->queryDataSet = val;
__isset.queryDataSet = true;
}

void TSExecuteStatementResp::__set_nonAlignQueryDataSet(const TSQueryNonAlignDataSet& val) {
  this->nonAlignQueryDataSet = val;
__isset.nonAlignQueryDataSet = true;
}

void TSExecuteStatementResp::__set_columnNameIndexMap(const std::map<std::string, int32_t> & val) {
  this->columnNameIndexMap = val;
__isset.columnNameIndexMap = true;
}
std::ostream& operator<<(std::ostream& out, const TSExecuteStatementResp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TSExecuteStatementResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_status = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          isset_status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->queryId);
          this->__isset.queryId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->columns.clear();
            uint32_t _size38;
            ::apache::thrift::protocol::TType _etype41;
            xfer += iprot->readListBegin(_etype41, _size38);
            this->columns.resize(_size38);
            uint32_t _i42;
            for (_i42 = 0; _i42 < _size38; ++_i42)
            {
              xfer += iprot->readString(this->columns[_i42]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.columns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->operationType);
          this->__isset.operationType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->ignoreTimeStamp);
          this->__isset.ignoreTimeStamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->dataTypeList.clear();
            uint32_t _size43;
            ::apache::thrift::protocol::TType _etype46;
            xfer += iprot->readListBegin(_etype46, _size43);
            this->dataTypeList.resize(_size43);
            uint32_t _i47;
            for (_i47 = 0; _i47 < _size43; ++_i47)
            {
              xfer += iprot->readString(this->dataTypeList[_i47]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.dataTypeList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->queryDataSet.read(iprot);
          this->__isset.queryDataSet = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->nonAlignQueryDataSet.read(iprot);
          this->__isset.nonAlignQueryDataSet = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->columnNameIndexMap.clear();
            uint32_t _size48;
            ::apache::thrift::protocol::TType _ktype49;
            ::apache::thrift::protocol::TType _vtype50;
            xfer += iprot->readMapBegin(_ktype49, _vtype50, _size48);
            uint32_t _i52;
            for (_i52 = 0; _i52 < _size48; ++_i52)
            {
              std::string _key53;
              xfer += iprot->readString(_key53);
              int32_t& _val54 = this->columnNameIndexMap[_key53];
              xfer += iprot->readI32(_val54);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.columnNameIndexMap = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_status)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TSExecuteStatementResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TSExecuteStatementResp");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->status.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.queryId) {
    xfer += oprot->writeFieldBegin("queryId", ::apache::thrift::protocol::T_I64, 2);
    xfer += oprot->writeI64(this->queryId);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.columns) {
    xfer += oprot->writeFieldBegin("columns", ::apache::thrift::protocol::T_LIST, 3);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->columns.size()));
      std::vector<std::string> ::const_iterator _iter55;
      for (_iter55 = this->columns.begin(); _iter55 != this->columns.end(); ++_iter55)
      {
        xfer += oprot->writeString((*_iter55));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.operationType) {
    xfer += oprot->writeFieldBegin("operationType", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->operationType);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ignoreTimeStamp) {
    xfer += oprot->writeFieldBegin("ignoreTimeStamp", ::apache::thrift::protocol::T_BOOL, 5);
    xfer += oprot->writeBool(this->ignoreTimeStamp);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.dataTypeList) {
    xfer += oprot->writeFieldBegin("dataTypeList", ::apache::thrift::protocol::T_LIST, 6);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->dataTypeList.size()));
      std::vector<std::string> ::const_iterator _iter56;
      for (_iter56 = this->dataTypeList.begin(); _iter56 != this->dataTypeList.end(); ++_iter56)
      {
        xfer += oprot->writeString((*_iter56));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.queryDataSet) {
    xfer += oprot->writeFieldBegin("queryDataSet", ::apache::thrift::protocol::T_STRUCT, 7);
    xfer += this->queryDataSet.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.nonAlignQueryDataSet) {
    xfer += oprot->writeFieldBegin("nonAlignQueryDataSet", ::apache::thrift::protocol::T_STRUCT, 8);
    xfer += this->nonAlignQueryDataSet.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.columnNameIndexMap) {
    xfer += oprot->writeFieldBegin("columnNameIndexMap", ::apache::thrift::protocol::T_MAP, 9);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->columnNameIndexMap.size()));
      std::map<std::string, int32_t> ::const_iterator _iter57;
      for (_iter57 = this->columnNameIndexMap.begin(); _iter57 != this->columnNameIndexMap.end(); ++_iter57)
      {
        xfer += oprot->writeString(_iter57->first);
        xfer += oprot->writeI32(_iter57->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TSExecuteStatementResp &a, TSExecuteStatementResp &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.queryId, b.queryId);
  swap(a.columns, b.columns);
  swap(a.operationType, b.operationType);
  swap(a.ignoreTimeStamp, b.ignoreTimeStamp);
  swap(a.dataTypeList, b.dataTypeList);
  swap(a.queryDataSet, b.queryDataSet);
  swap(a.nonAlignQueryDataSet, b.nonAlignQueryDataSet);
  swap(a.columnNameIndexMap, b.columnNameIndexMap);
  swap(a.__isset, b.__isset);
}

TSExecuteStatementResp::TSExecuteStatementResp(const TSExecuteStatementResp& other58) {
  status = other58.status;
  queryId = other58.queryId;
  columns = other58.columns;
  operationType = other58.operationType;
  ignoreTimeStamp = other58.ignoreTimeStamp;
  dataTypeList = other58.dataTypeList;
  queryDataSet = other58.queryDataSet;
  nonAlignQueryDataSet = other58.nonAlignQueryDataSet;
  columnNameIndexMap = other58.columnNameIndexMap;
  __isset = other58.__isset;
}
TSExecuteStatementResp& TSExecuteStatementResp::operator=(const TSExecuteStatementResp& other59) {
  status = other59.status;
  queryId = other59.queryId;
  columns = other59.columns;
  operationType = other59.operationType;
  ignoreTimeStamp = other59.ignoreTimeStamp;
  dataTypeList = other59.dataTypeList;
  queryDataSet = other59.queryDataSet;
  nonAlignQueryDataSet = other59.nonAlignQueryDataSet;
  columnNameIndexMap = other59.columnNameIndexMap;
  __isset = other59.__isset;
  return *this;
}
void TSExecuteStatementResp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TSExecuteStatementResp(";
  out << "status=" << to_string(status);
  out << ", " << "queryId="; (__isset.queryId ? (out << to_string(queryId)) : (out << "<null>"));
  out << ", " << "columns="; (__isset.columns ? (out << to_string(columns)) : (out << "<null>"));
  out << ", " << "operationType="; (__isset.operationType ? (out << to_string(operationType)) : (out << "<null>"));
  out << ", " << "ignoreTimeStamp="; (__isset.ignoreTimeStamp ? (out << to_string(ignoreTimeStamp)) : (out << "<null>"));
  out << ", " << "dataTypeList="; (__isset.dataTypeList ? (out << to_string(dataTypeList)) : (out << "<null>"));
  out << ", " << "queryDataSet="; (__isset.queryDataSet ? (out << to_string(queryDataSet)) : (out << "<null>"));
  out << ", " << "nonAlignQueryDataSet="; (__isset.nonAlignQueryDataSet ? (out << to_string(nonAlignQueryDataSet)) : (out << "<null>"));
  out << ", " << "columnNameIndexMap="; (__isset.columnNameIndexMap ? (out << to_string(columnNameIndexMap)) : (out << "<null>"));
  out << ")";
}


TSOpenSessionResp::~TSOpenSessionResp() noexcept {
}


void TSOpenSessionResp::__set_status(const TSStatus& val) {
  this->status = val;
}

void TSOpenSessionResp::__set_serverProtocolVersion(const TSProtocolVersion::type val) {
  this->serverProtocolVersion = val;
}

void TSOpenSessionResp::__set_sessionId(const int64_t val) {
  this->sessionId = val;
__isset.sessionId = true;
}

void TSOpenSessionResp::__set_configuration(const std::map<std::string, std::string> & val) {
  this->configuration = val;
__isset.configuration = true;
}
std::ostream& operator<<(std::ostream& out, const TSOpenSessionResp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TSOpenSessionResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_status = false;
  bool isset_serverProtocolVersion = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          isset_status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast60;
          xfer += iprot->readI32(ecast60);
          this->serverProtocolVersion = (TSProtocolVersion::type)ecast60;
          isset_serverProtocolVersion = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->sessionId);
          this->__isset.sessionId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->configuration.clear();
            uint32_t _size61;
            ::apache::thrift::protocol::TType _ktype62;
            ::apache::thrift::protocol::TType _vtype63;
            xfer += iprot->readMapBegin(_ktype62, _vtype63, _size61);
            uint32_t _i65;
            for (_i65 = 0; _i65 < _size61; ++_i65)
            {
              std::string _key66;
              xfer += iprot->readString(_key66);
              std::string& _val67 = this->configuration[_key66];
              xfer += iprot->readString(_val67);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.configuration = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_status)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_serverProtocolVersion)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TSOpenSessionResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TSOpenSessionResp");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->status.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("serverProtocolVersion", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->serverProtocolVersion);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.sessionId) {
    xfer += oprot->writeFieldBegin("sessionId", ::apache::thrift::protocol::T_I64, 3);
    xfer += oprot->writeI64(this->sessionId);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.configuration) {
    xfer += oprot->writeFieldBegin("configuration", ::apache::thrift::protocol::T_MAP, 4);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->configuration.size()));
      std::map<std::string, std::string> ::const_iterator _iter68;
      for (_iter68 = this->configuration.begin(); _iter68 != this->configuration.end(); ++_iter68)
      {
        xfer += oprot->writeString(_iter68->first);
        xfer += oprot->writeString(_iter68->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TSOpenSessionResp &a, TSOpenSessionResp &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.serverProtocolVersion, b.serverProtocolVersion);
  swap(a.sessionId, b.sessionId);
  swap(a.configuration, b.configuration);
  swap(a.__isset, b.__isset);
}

TSOpenSessionResp::TSOpenSessionResp(const TSOpenSessionResp& other69) {
  status = other69.status;
  serverProtocolVersion = other69.serverProtocolVersion;
  sessionId = other69.sessionId;
  configuration = other69.configuration;
  __isset = other69.__isset;
}
TSOpenSessionResp& TSOpenSessionResp::operator=(const TSOpenSessionResp& other70) {
  status = other70.status;
  serverProtocolVersion = other70.serverProtocolVersion;
  sessionId = other70.sessionId;
  configuration = other70.configuration;
  __isset = other70.__isset;
  return *this;
}
void TSOpenSessionResp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TSOpenSessionResp(";
  out << "status=" << to_string(status);
  out << ", " << "serverProtocolVersion=" << to_string(serverProtocolVersion);
  out << ", " << "sessionId="; (__isset.sessionId ? (out << to_string(sessionId)) : (out << "<null>"));
  out << ", " << "configuration="; (__isset.configuration ? (out << to_string(configuration)) : (out << "<null>"));
  out << ")";
}


TSOpenSessionReq::~TSOpenSessionReq() noexcept {
}


void TSOpenSessionReq::__set_client_protocol(const TSProtocolVersion::type val) {
  this->client_protocol = val;
}

void TSOpenSessionReq::__set_zoneId(const std::string& val) {
  this->zoneId = val;
}

void TSOpenSessionReq::__set_username(const std::string& val) {
  this->username = val;
__isset.username = true;
}

void TSOpenSessionReq::__set_password(const std::string& val) {
  this->password = val;
__isset.password = true;
}

void TSOpenSessionReq::__set_configuration(const std::map<std::string, std::string> & val) {
  this->configuration = val;
__isset.configuration = true;
}
std::ostream& operator<<(std::ostream& out, const TSOpenSessionReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TSOpenSessionReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_client_protocol = false;
  bool isset_zoneId = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast71;
          xfer += iprot->readI32(ecast71);
          this->client_protocol = (TSProtocolVersion::type)ecast71;
          isset_client_protocol = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->zoneId);
          isset_zoneId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->username);
          this->__isset.username = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->password);
          this->__isset.password = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->configuration.clear();
            uint32_t _size72;
            ::apache::thrift::protocol::TType _ktype73;
            ::apache::thrift::protocol::TType _vtype74;
            xfer += iprot->readMapBegin(_ktype73, _vtype74, _size72);
            uint32_t _i76;
            for (_i76 = 0; _i76 < _size72; ++_i76)
            {
              std::string _key77;
              xfer += iprot->readString(_key77);
              std::string& _val78 = this->configuration[_key77];
              xfer += iprot->readString(_val78);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.configuration = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_client_protocol)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_zoneId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TSOpenSessionReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TSOpenSessionReq");

  xfer += oprot->writeFieldBegin("client_protocol", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->client_protocol);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("zoneId", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->zoneId);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.username) {
    xfer += oprot->writeFieldBegin("username", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->username);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.password) {
    xfer += oprot->writeFieldBegin("password", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->password);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.configuration) {
    xfer += oprot->writeFieldBegin("configuration", ::apache::thrift::protocol::T_MAP, 5);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->configuration.size()));
      std::map<std::string, std::string> ::const_iterator _iter79;
      for (_iter79 = this->configuration.begin(); _iter79 != this->configuration.end(); ++_iter79)
      {
        xfer += oprot->writeString(_iter79->first);
        xfer += oprot->writeString(_iter79->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TSOpenSessionReq &a, TSOpenSessionReq &b) {
  using ::std::swap;
  swap(a.client_protocol, b.client_protocol);
  swap(a.zoneId, b.zoneId);
  swap(a.username, b.username);
  swap(a.password, b.password);
  swap(a.configuration, b.configuration);
  swap(a.__isset, b.__isset);
}

TSOpenSessionReq::TSOpenSessionReq(const TSOpenSessionReq& other80) {
  client_protocol = other80.client_protocol;
  zoneId = other80.zoneId;
  username = other80.username;
  password = other80.password;
  configuration = other80.configuration;
  __isset = other80.__isset;
}
TSOpenSessionReq& TSOpenSessionReq::operator=(const TSOpenSessionReq& other81) {
  client_protocol = other81.client_protocol;
  zoneId = other81.zoneId;
  username = other81.username;
  password = other81.password;
  configuration = other81.configuration;
  __isset = other81.__isset;
  return *this;
}
void TSOpenSessionReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TSOpenSessionReq(";
  out << "client_protocol=" << to_string(client_protocol);
  out << ", " << "zoneId=" << to_string(zoneId);
  out << ", " << "username="; (__isset.username ? (out << to_string(username)) : (out << "<null>"));
  out << ", " << "password="; (__isset.password ? (out << to_string(password)) : (out << "<null>"));
  out << ", " << "configuration="; (__isset.configuration ? (out << to_string(configuration)) : (out << "<null>"));
  out << ")";
}


TSCloseSessionReq::~TSCloseSessionReq() noexcept {
}


void TSCloseSessionReq::__set_sessionId(const int64_t val) {
  this->sessionId = val;
}
std::ostream& operator<<(std::ostream& out, const TSCloseSessionReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TSCloseSessionReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_sessionId = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->sessionId);
          isset_sessionId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_sessionId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TSCloseSessionReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TSCloseSessionReq");

  xfer += oprot->writeFieldBegin("sessionId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->sessionId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TSCloseSessionReq &a, TSCloseSessionReq &b) {
  using ::std::swap;
  swap(a.sessionId, b.sessionId);
}

TSCloseSessionReq::TSCloseSessionReq(const TSCloseSessionReq& other82) {
  sessionId = other82.sessionId;
}
TSCloseSessionReq& TSCloseSessionReq::operator=(const TSCloseSessionReq& other83) {
  sessionId = other83.sessionId;
  return *this;
}
void TSCloseSessionReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TSCloseSessionReq(";
  out << "sessionId=" << to_string(sessionId);
  out << ")";
}


TSExecuteStatementReq::~TSExecuteStatementReq() noexcept {
}


void TSExecuteStatementReq::__set_sessionId(const int64_t val) {
  this->sessionId = val;
}

void TSExecuteStatementReq::__set_statement(const std::string& val) {
  this->statement = val;
}

void TSExecuteStatementReq::__set_statementId(const int64_t val) {
  this->statementId = val;
}

void TSExecuteStatementReq::__set_fetchSize(const int32_t val) {
  this->fetchSize = val;
__isset.fetchSize = true;
}

void TSExecuteStatementReq::__set_timeout(const int64_t val) {
  this->timeout = val;
__isset.timeout = true;
}

void TSExecuteStatementReq::__set_enableRedirectQuery(const bool val) {
  this->enableRedirectQuery = val;
__isset.enableRedirectQuery = true;
}
std::ostream& operator<<(std::ostream& out, const TSExecuteStatementReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TSExecuteStatementReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_sessionId = false;
  bool isset_statement = false;
  bool isset_statementId = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->sessionId);
          isset_sessionId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->statement);
          isset_statement = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->statementId);
          isset_statementId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->fetchSize);
          this->__isset.fetchSize = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->timeout);
          this->__isset.timeout = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->enableRedirectQuery);
          this->__isset.enableRedirectQuery = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_sessionId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_statement)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_statementId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TSExecuteStatementReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TSExecuteStatementReq");

  xfer += oprot->writeFieldBegin("sessionId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->sessionId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("statement", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->statement);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("statementId", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->statementId);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.fetchSize) {
    xfer += oprot->writeFieldBegin("fetchSize", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32(this->fetchSize);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.timeout) {
    xfer += oprot->writeFieldBegin("timeout", ::apache::thrift::protocol::T_I64, 5);
    xfer += oprot->writeI64(this->timeout);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.enableRedirectQuery) {
    xfer += oprot->writeFieldBegin("enableRedirectQuery", ::apache::thrift::protocol::T_BOOL, 6);
    xfer += oprot->writeBool(this->enableRedirectQuery);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TSExecuteStatementReq &a, TSExecuteStatementReq &b) {
  using ::std::swap;
  swap(a.sessionId, b.sessionId);
  swap(a.statement, b.statement);
  swap(a.statementId, b.statementId);
  swap(a.fetchSize, b.fetchSize);
  swap(a.timeout, b.timeout);
  swap(a.enableRedirectQuery, b.enableRedirectQuery);
  swap(a.__isset, b.__isset);
}

TSExecuteStatementReq::TSExecuteStatementReq(const TSExecuteStatementReq& other84) {
  sessionId = other84.sessionId;
  statement = other84.statement;
  statementId = other84.statementId;
  fetchSize = other84.fetchSize;
  timeout = other84.timeout;
  enableRedirectQuery = other84.enableRedirectQuery;
  __isset = other84.__isset;
}
TSExecuteStatementReq& TSExecuteStatementReq::operator=(const TSExecuteStatementReq& other85) {
  sessionId = other85.sessionId;
  statement = other85.statement;
  statementId = other85.statementId;
  fetchSize = other85.fetchSize;
  timeout = other85.timeout;
  enableRedirectQuery = other85.enableRedirectQuery;
  __isset = other85.__isset;
  return *this;
}
void TSExecuteStatementReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TSExecuteStatementReq(";
  out << "sessionId=" << to_string(sessionId);
  out << ", " << "statement=" << to_string(statement);
  out << ", " << "statementId=" << to_string(statementId);
  out << ", " << "fetchSize="; (__isset.fetchSize ? (out << to_string(fetchSize)) : (out << "<null>"));
  out << ", " << "timeout="; (__isset.timeout ? (out << to_string(timeout)) : (out << "<null>"));
  out << ", " << "enableRedirectQuery="; (__isset.enableRedirectQuery ? (out << to_string(enableRedirectQuery)) : (out << "<null>"));
  out << ")";
}


TSExecuteBatchStatementReq::~TSExecuteBatchStatementReq() noexcept {
}


void TSExecuteBatchStatementReq::__set_sessionId(const int64_t val) {
  this->sessionId = val;
}

void TSExecuteBatchStatementReq::__set_statements(const std::vector<std::string> & val) {
  this->statements = val;
}
std::ostream& operator<<(std::ostream& out, const TSExecuteBatchStatementReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TSExecuteBatchStatementReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_sessionId = false;
  bool isset_statements = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->sessionId);
          isset_sessionId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->statements.clear();
            uint32_t _size86;
            ::apache::thrift::protocol::TType _etype89;
            xfer += iprot->readListBegin(_etype89, _size86);
            this->statements.resize(_size86);
            uint32_t _i90;
            for (_i90 = 0; _i90 < _size86; ++_i90)
            {
              xfer += iprot->readString(this->statements[_i90]);
            }
            xfer += iprot->readListEnd();
          }
          isset_statements = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_sessionId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_statements)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TSExecuteBatchStatementReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TSExecuteBatchStatementReq");

  xfer += oprot->writeFieldBegin("sessionId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->sessionId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("statements", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->statements.size()));
    std::vector<std::string> ::const_iterator _iter91;
    for (_iter91 = this->statements.begin(); _iter91 != this->statements.end(); ++_iter91)
    {
      xfer += oprot->writeString((*_iter91));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TSExecuteBatchStatementReq &a, TSExecuteBatchStatementReq &b) {
  using ::std::swap;
  swap(a.sessionId, b.sessionId);
  swap(a.statements, b.statements);
}

TSExecuteBatchStatementReq::TSExecuteBatchStatementReq(const TSExecuteBatchStatementReq& other92) {
  sessionId = other92.sessionId;
  statements = other92.statements;
}
TSExecuteBatchStatementReq& TSExecuteBatchStatementReq::operator=(const TSExecuteBatchStatementReq& other93) {
  sessionId = other93.sessionId;
  statements = other93.statements;
  return *this;
}
void TSExecuteBatchStatementReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TSExecuteBatchStatementReq(";
  out << "sessionId=" << to_string(sessionId);
  out << ", " << "statements=" << to_string(statements);
  out << ")";
}


TSGetOperationStatusReq::~TSGetOperationStatusReq() noexcept {
}


void TSGetOperationStatusReq::__set_sessionId(const int64_t val) {
  this->sessionId = val;
}

void TSGetOperationStatusReq::__set_queryId(const int64_t val) {
  this->queryId = val;
}
std::ostream& operator<<(std::ostream& out, const TSGetOperationStatusReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TSGetOperationStatusReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_sessionId = false;
  bool isset_queryId = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->sessionId);
          isset_sessionId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->queryId);
          isset_queryId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_sessionId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_queryId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TSGetOperationStatusReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TSGetOperationStatusReq");

  xfer += oprot->writeFieldBegin("sessionId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->sessionId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("queryId", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->queryId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TSGetOperationStatusReq &a, TSGetOperationStatusReq &b) {
  using ::std::swap;
  swap(a.sessionId, b.sessionId);
  swap(a.queryId, b.queryId);
}

TSGetOperationStatusReq::TSGetOperationStatusReq(const TSGetOperationStatusReq& other94) {
  sessionId = other94.sessionId;
  queryId = other94.queryId;
}
TSGetOperationStatusReq& TSGetOperationStatusReq::operator=(const TSGetOperationStatusReq& other95) {
  sessionId = other95.sessionId;
  queryId = other95.queryId;
  return *this;
}
void TSGetOperationStatusReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TSGetOperationStatusReq(";
  out << "sessionId=" << to_string(sessionId);
  out << ", " << "queryId=" << to_string(queryId);
  out << ")";
}


TSCancelOperationReq::~TSCancelOperationReq() noexcept {
}


void TSCancelOperationReq::__set_sessionId(const int64_t val) {
  this->sessionId = val;
}

void TSCancelOperationReq::__set_queryId(const int64_t val) {
  this->queryId = val;
}
std::ostream& operator<<(std::ostream& out, const TSCancelOperationReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TSCancelOperationReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_sessionId = false;
  bool isset_queryId = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->sessionId);
          isset_sessionId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->queryId);
          isset_queryId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_sessionId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_queryId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TSCancelOperationReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TSCancelOperationReq");

  xfer += oprot->writeFieldBegin("sessionId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->sessionId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("queryId", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->queryId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TSCancelOperationReq &a, TSCancelOperationReq &b) {
  using ::std::swap;
  swap(a.sessionId, b.sessionId);
  swap(a.queryId, b.queryId);
}

TSCancelOperationReq::TSCancelOperationReq(const TSCancelOperationReq& other96) {
  sessionId = other96.sessionId;
  queryId = other96.queryId;
}
TSCancelOperationReq& TSCancelOperationReq::operator=(const TSCancelOperationReq& other97) {
  sessionId = other97.sessionId;
  queryId = other97.queryId;
  return *this;
}
void TSCancelOperationReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TSCancelOperationReq(";
  out << "sessionId=" << to_string(sessionId);
  out << ", " << "queryId=" << to_string(queryId);
  out << ")";
}


TSCloseOperationReq::~TSCloseOperationReq() noexcept {
}


void TSCloseOperationReq::__set_sessionId(const int64_t val) {
  this->sessionId = val;
}

void TSCloseOperationReq::__set_queryId(const int64_t val) {
  this->queryId = val;
__isset.queryId = true;
}

void TSCloseOperationReq::__set_statementId(const int64_t val) {
  this->statementId = val;
__isset.statementId = true;
}
std::ostream& operator<<(std::ostream& out, const TSCloseOperationReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TSCloseOperationReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_sessionId = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->sessionId);
          isset_sessionId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->queryId);
          this->__isset.queryId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->statementId);
          this->__isset.statementId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_sessionId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TSCloseOperationReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TSCloseOperationReq");

  xfer += oprot->writeFieldBegin("sessionId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->sessionId);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.queryId) {
    xfer += oprot->writeFieldBegin("queryId", ::apache::thrift::protocol::T_I64, 2);
    xfer += oprot->writeI64(this->queryId);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.statementId) {
    xfer += oprot->writeFieldBegin("statementId", ::apache::thrift::protocol::T_I64, 3);
    xfer += oprot->writeI64(this->statementId);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TSCloseOperationReq &a, TSCloseOperationReq &b) {
  using ::std::swap;
  swap(a.sessionId, b.sessionId);
  swap(a.queryId, b.queryId);
  swap(a.statementId, b.statementId);
  swap(a.__isset, b.__isset);
}

TSCloseOperationReq::TSCloseOperationReq(const TSCloseOperationReq& other98) {
  sessionId = other98.sessionId;
  queryId = other98.queryId;
  statementId = other98.statementId;
  __isset = other98.__isset;
}
TSCloseOperationReq& TSCloseOperationReq::operator=(const TSCloseOperationReq& other99) {
  sessionId = other99.sessionId;
  queryId = other99.queryId;
  statementId = other99.statementId;
  __isset = other99.__isset;
  return *this;
}
void TSCloseOperationReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TSCloseOperationReq(";
  out << "sessionId=" << to_string(sessionId);
  out << ", " << "queryId="; (__isset.queryId ? (out << to_string(queryId)) : (out << "<null>"));
  out << ", " << "statementId="; (__isset.statementId ? (out << to_string(statementId)) : (out << "<null>"));
  out << ")";
}


TSFetchResultsReq::~TSFetchResultsReq() noexcept {
}


void TSFetchResultsReq::__set_sessionId(const int64_t val) {
  this->sessionId = val;
}

void TSFetchResultsReq::__set_statement(const std::string& val) {
  this->statement = val;
}

void TSFetchResultsReq::__set_fetchSize(const int32_t val) {
  this->fetchSize = val;
}

void TSFetchResultsReq::__set_queryId(const int64_t val) {
  this->queryId = val;
}

void TSFetchResultsReq::__set_isAlign(const bool val) {
  this->isAlign = val;
}

void TSFetchResultsReq::__set_timeout(const int64_t val) {
  this->timeout = val;
__isset.timeout = true;
}
std::ostream& operator<<(std::ostream& out, const TSFetchResultsReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TSFetchResultsReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_sessionId = false;
  bool isset_statement = false;
  bool isset_fetchSize = false;
  bool isset_queryId = false;
  bool isset_isAlign = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->sessionId);
          isset_sessionId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->statement);
          isset_statement = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->fetchSize);
          isset_fetchSize = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->queryId);
          isset_queryId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->isAlign);
          isset_isAlign = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->timeout);
          this->__isset.timeout = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_sessionId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_statement)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_fetchSize)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_queryId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_isAlign)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TSFetchResultsReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TSFetchResultsReq");

  xfer += oprot->writeFieldBegin("sessionId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->sessionId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("statement", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->statement);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("fetchSize", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->fetchSize);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("queryId", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->queryId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("isAlign", ::apache::thrift::protocol::T_BOOL, 5);
  xfer += oprot->writeBool(this->isAlign);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.timeout) {
    xfer += oprot->writeFieldBegin("timeout", ::apache::thrift::protocol::T_I64, 6);
    xfer += oprot->writeI64(this->timeout);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TSFetchResultsReq &a, TSFetchResultsReq &b) {
  using ::std::swap;
  swap(a.sessionId, b.sessionId);
  swap(a.statement, b.statement);
  swap(a.fetchSize, b.fetchSize);
  swap(a.queryId, b.queryId);
  swap(a.isAlign, b.isAlign);
  swap(a.timeout, b.timeout);
  swap(a.__isset, b.__isset);
}

TSFetchResultsReq::TSFetchResultsReq(const TSFetchResultsReq& other100) {
  sessionId = other100.sessionId;
  statement = other100.statement;
  fetchSize = other100.fetchSize;
  queryId = other100.queryId;
  isAlign = other100.isAlign;
  timeout = other100.timeout;
  __isset = other100.__isset;
}
TSFetchResultsReq& TSFetchResultsReq::operator=(const TSFetchResultsReq& other101) {
  sessionId = other101.sessionId;
  statement = other101.statement;
  fetchSize = other101.fetchSize;
  queryId = other101.queryId;
  isAlign = other101.isAlign;
  timeout = other101.timeout;
  __isset = other101.__isset;
  return *this;
}
void TSFetchResultsReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TSFetchResultsReq(";
  out << "sessionId=" << to_string(sessionId);
  out << ", " << "statement=" << to_string(statement);
  out << ", " << "fetchSize=" << to_string(fetchSize);
  out << ", " << "queryId=" << to_string(queryId);
  out << ", " << "isAlign=" << to_string(isAlign);
  out << ", " << "timeout="; (__isset.timeout ? (out << to_string(timeout)) : (out << "<null>"));
  out << ")";
}


TSFetchResultsResp::~TSFetchResultsResp() noexcept {
}


void TSFetchResultsResp::__set_status(const TSStatus& val) {
  this->status = val;
}

void TSFetchResultsResp::__set_hasResultSet(const bool val) {
  this->hasResultSet = val;
}

void TSFetchResultsResp::__set_isAlign(const bool val) {
  this->isAlign = val;
}

void TSFetchResultsResp::__set_queryDataSet(const TSQueryDataSet& val) {
  this->queryDataSet = val;
__isset.queryDataSet = true;
}

void TSFetchResultsResp::__set_nonAlignQueryDataSet(const TSQueryNonAlignDataSet& val) {
  this->nonAlignQueryDataSet = val;
__isset.nonAlignQueryDataSet = true;
}
std::ostream& operator<<(std::ostream& out, const TSFetchResultsResp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TSFetchResultsResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_status = false;
  bool isset_hasResultSet = false;
  bool isset_isAlign = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          isset_status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->hasResultSet);
          isset_hasResultSet = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->isAlign);
          isset_isAlign = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->queryDataSet.read(iprot);
          this->__isset.queryDataSet = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->nonAlignQueryDataSet.read(iprot);
          this->__isset.nonAlignQueryDataSet = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_status)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_hasResultSet)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_isAlign)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TSFetchResultsResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TSFetchResultsResp");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->status.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("hasResultSet", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->hasResultSet);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("isAlign", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->isAlign);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.queryDataSet) {
    xfer += oprot->writeFieldBegin("queryDataSet", ::apache::thrift::protocol::T_STRUCT, 4);
    xfer += this->queryDataSet.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.nonAlignQueryDataSet) {
    xfer += oprot->writeFieldBegin("nonAlignQueryDataSet", ::apache::thrift::protocol::T_STRUCT, 5);
    xfer += this->nonAlignQueryDataSet.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TSFetchResultsResp &a, TSFetchResultsResp &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.hasResultSet, b.hasResultSet);
  swap(a.isAlign, b.isAlign);
  swap(a.queryDataSet, b.queryDataSet);
  swap(a.nonAlignQueryDataSet, b.nonAlignQueryDataSet);
  swap(a.__isset, b.__isset);
}

TSFetchResultsResp::TSFetchResultsResp(const TSFetchResultsResp& other102) {
  status = other102.status;
  hasResultSet = other102.hasResultSet;
  isAlign = other102.isAlign;
  queryDataSet = other102.queryDataSet;
  nonAlignQueryDataSet = other102.nonAlignQueryDataSet;
  __isset = other102.__isset;
}
TSFetchResultsResp& TSFetchResultsResp::operator=(const TSFetchResultsResp& other103) {
  status = other103.status;
  hasResultSet = other103.hasResultSet;
  isAlign = other103.isAlign;
  queryDataSet = other103.queryDataSet;
  nonAlignQueryDataSet = other103.nonAlignQueryDataSet;
  __isset = other103.__isset;
  return *this;
}
void TSFetchResultsResp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TSFetchResultsResp(";
  out << "status=" << to_string(status);
  out << ", " << "hasResultSet=" << to_string(hasResultSet);
  out << ", " << "isAlign=" << to_string(isAlign);
  out << ", " << "queryDataSet="; (__isset.queryDataSet ? (out << to_string(queryDataSet)) : (out << "<null>"));
  out << ", " << "nonAlignQueryDataSet="; (__isset.nonAlignQueryDataSet ? (out << to_string(nonAlignQueryDataSet)) : (out << "<null>"));
  out << ")";
}


TSFetchMetadataResp::~TSFetchMetadataResp() noexcept {
}


void TSFetchMetadataResp::__set_status(const TSStatus& val) {
  this->status = val;
}

void TSFetchMetadataResp::__set_metadataInJson(const std::string& val) {
  this->metadataInJson = val;
__isset.metadataInJson = true;
}

void TSFetchMetadataResp::__set_columnsList(const std::vector<std::string> & val) {
  this->columnsList = val;
__isset.columnsList = true;
}

void TSFetchMetadataResp::__set_dataType(const std::string& val) {
  this->dataType = val;
__isset.dataType = true;
}
std::ostream& operator<<(std::ostream& out, const TSFetchMetadataResp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TSFetchMetadataResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_status = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          isset_status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->metadataInJson);
          this->__isset.metadataInJson = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->columnsList.clear();
            uint32_t _size104;
            ::apache::thrift::protocol::TType _etype107;
            xfer += iprot->readListBegin(_etype107, _size104);
            this->columnsList.resize(_size104);
            uint32_t _i108;
            for (_i108 = 0; _i108 < _size104; ++_i108)
            {
              xfer += iprot->readString(this->columnsList[_i108]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.columnsList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dataType);
          this->__isset.dataType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_status)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TSFetchMetadataResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TSFetchMetadataResp");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->status.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.metadataInJson) {
    xfer += oprot->writeFieldBegin("metadataInJson", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->metadataInJson);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.columnsList) {
    xfer += oprot->writeFieldBegin("columnsList", ::apache::thrift::protocol::T_LIST, 3);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->columnsList.size()));
      std::vector<std::string> ::const_iterator _iter109;
      for (_iter109 = this->columnsList.begin(); _iter109 != this->columnsList.end(); ++_iter109)
      {
        xfer += oprot->writeString((*_iter109));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.dataType) {
    xfer += oprot->writeFieldBegin("dataType", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->dataType);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TSFetchMetadataResp &a, TSFetchMetadataResp &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.metadataInJson, b.metadataInJson);
  swap(a.columnsList, b.columnsList);
  swap(a.dataType, b.dataType);
  swap(a.__isset, b.__isset);
}

TSFetchMetadataResp::TSFetchMetadataResp(const TSFetchMetadataResp& other110) {
  status = other110.status;
  metadataInJson = other110.metadataInJson;
  columnsList = other110.columnsList;
  dataType = other110.dataType;
  __isset = other110.__isset;
}
TSFetchMetadataResp& TSFetchMetadataResp::operator=(const TSFetchMetadataResp& other111) {
  status = other111.status;
  metadataInJson = other111.metadataInJson;
  columnsList = other111.columnsList;
  dataType = other111.dataType;
  __isset = other111.__isset;
  return *this;
}
void TSFetchMetadataResp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TSFetchMetadataResp(";
  out << "status=" << to_string(status);
  out << ", " << "metadataInJson="; (__isset.metadataInJson ? (out << to_string(metadataInJson)) : (out << "<null>"));
  out << ", " << "columnsList="; (__isset.columnsList ? (out << to_string(columnsList)) : (out << "<null>"));
  out << ", " << "dataType="; (__isset.dataType ? (out << to_string(dataType)) : (out << "<null>"));
  out << ")";
}


TSFetchMetadataReq::~TSFetchMetadataReq() noexcept {
}


void TSFetchMetadataReq::__set_sessionId(const int64_t val) {
  this->sessionId = val;
}

void TSFetchMetadataReq::__set_type(const std::string& val) {
  this->type = val;
}

void TSFetchMetadataReq::__set_columnPath(const std::string& val) {
  this->columnPath = val;
__isset.columnPath = true;
}
std::ostream& operator<<(std::ostream& out, const TSFetchMetadataReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TSFetchMetadataReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_sessionId = false;
  bool isset_type = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->sessionId);
          isset_sessionId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->type);
          isset_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->columnPath);
          this->__isset.columnPath = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_sessionId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TSFetchMetadataReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TSFetchMetadataReq");

  xfer += oprot->writeFieldBegin("sessionId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->sessionId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->type);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.columnPath) {
    xfer += oprot->writeFieldBegin("columnPath", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->columnPath);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TSFetchMetadataReq &a, TSFetchMetadataReq &b) {
  using ::std::swap;
  swap(a.sessionId, b.sessionId);
  swap(a.type, b.type);
  swap(a.columnPath, b.columnPath);
  swap(a.__isset, b.__isset);
}

TSFetchMetadataReq::TSFetchMetadataReq(const TSFetchMetadataReq& other112) {
  sessionId = other112.sessionId;
  type = other112.type;
  columnPath = other112.columnPath;
  __isset = other112.__isset;
}
TSFetchMetadataReq& TSFetchMetadataReq::operator=(const TSFetchMetadataReq& other113) {
  sessionId = other113.sessionId;
  type = other113.type;
  columnPath = other113.columnPath;
  __isset = other113.__isset;
  return *this;
}
void TSFetchMetadataReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TSFetchMetadataReq(";
  out << "sessionId=" << to_string(sessionId);
  out << ", " << "type=" << to_string(type);
  out << ", " << "columnPath="; (__isset.columnPath ? (out << to_string(columnPath)) : (out << "<null>"));
  out << ")";
}


TSGetTimeZoneResp::~TSGetTimeZoneResp() noexcept {
}


void TSGetTimeZoneResp::__set_status(const TSStatus& val) {
  this->status = val;
}

void TSGetTimeZoneResp::__set_timeZone(const std::string& val) {
  this->timeZone = val;
}
std::ostream& operator<<(std::ostream& out, const TSGetTimeZoneResp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TSGetTimeZoneResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_status = false;
  bool isset_timeZone = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          isset_status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->timeZone);
          isset_timeZone = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_status)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_timeZone)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TSGetTimeZoneResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TSGetTimeZoneResp");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->status.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("timeZone", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->timeZone);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TSGetTimeZoneResp &a, TSGetTimeZoneResp &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.timeZone, b.timeZone);
}

TSGetTimeZoneResp::TSGetTimeZoneResp(const TSGetTimeZoneResp& other114) {
  status = other114.status;
  timeZone = other114.timeZone;
}
TSGetTimeZoneResp& TSGetTimeZoneResp::operator=(const TSGetTimeZoneResp& other115) {
  status = other115.status;
  timeZone = other115.timeZone;
  return *this;
}
void TSGetTimeZoneResp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TSGetTimeZoneResp(";
  out << "status=" << to_string(status);
  out << ", " << "timeZone=" << to_string(timeZone);
  out << ")";
}


TSSetTimeZoneReq::~TSSetTimeZoneReq() noexcept {
}


void TSSetTimeZoneReq::__set_sessionId(const int64_t val) {
  this->sessionId = val;
}

void TSSetTimeZoneReq::__set_timeZone(const std::string& val) {
  this->timeZone = val;
}
std::ostream& operator<<(std::ostream& out, const TSSetTimeZoneReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TSSetTimeZoneReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_sessionId = false;
  bool isset_timeZone = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->sessionId);
          isset_sessionId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->timeZone);
          isset_timeZone = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_sessionId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_timeZone)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TSSetTimeZoneReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TSSetTimeZoneReq");

  xfer += oprot->writeFieldBegin("sessionId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->sessionId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("timeZone", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->timeZone);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TSSetTimeZoneReq &a, TSSetTimeZoneReq &b) {
  using ::std::swap;
  swap(a.sessionId, b.sessionId);
  swap(a.timeZone, b.timeZone);
}

TSSetTimeZoneReq::TSSetTimeZoneReq(const TSSetTimeZoneReq& other116) {
  sessionId = other116.sessionId;
  timeZone = other116.timeZone;
}
TSSetTimeZoneReq& TSSetTimeZoneReq::operator=(const TSSetTimeZoneReq& other117) {
  sessionId = other117.sessionId;
  timeZone = other117.timeZone;
  return *this;
}
void TSSetTimeZoneReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TSSetTimeZoneReq(";
  out << "sessionId=" << to_string(sessionId);
  out << ", " << "timeZone=" << to_string(timeZone);
  out << ")";
}


TSInsertRecordReq::~TSInsertRecordReq() noexcept {
}


void TSInsertRecordReq::__set_sessionId(const int64_t val) {
  this->sessionId = val;
}

void TSInsertRecordReq::__set_deviceId(const std::string& val) {
  this->deviceId = val;
}

void TSInsertRecordReq::__set_measurements(const std::vector<std::string> & val) {
  this->measurements = val;
}

void TSInsertRecordReq::__set_values(const std::string& val) {
  this->values = val;
}

void TSInsertRecordReq::__set_timestamp(const int64_t val) {
  this->timestamp = val;
}
std::ostream& operator<<(std::ostream& out, const TSInsertRecordReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TSInsertRecordReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_sessionId = false;
  bool isset_deviceId = false;
  bool isset_measurements = false;
  bool isset_values = false;
  bool isset_timestamp = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->sessionId);
          isset_sessionId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->deviceId);
          isset_deviceId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->measurements.clear();
            uint32_t _size118;
            ::apache::thrift::protocol::TType _etype121;
            xfer += iprot->readListBegin(_etype121, _size118);
            this->measurements.resize(_size118);
            uint32_t _i122;
            for (_i122 = 0; _i122 < _size118; ++_i122)
            {
              xfer += iprot->readString(this->measurements[_i122]);
            }
            xfer += iprot->readListEnd();
          }
          isset_measurements = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->values);
          isset_values = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->timestamp);
          isset_timestamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_sessionId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_deviceId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_measurements)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_values)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_timestamp)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TSInsertRecordReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TSInsertRecordReq");

  xfer += oprot->writeFieldBegin("sessionId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->sessionId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("deviceId", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->deviceId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("measurements", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->measurements.size()));
    std::vector<std::string> ::const_iterator _iter123;
    for (_iter123 = this->measurements.begin(); _iter123 != this->measurements.end(); ++_iter123)
    {
      xfer += oprot->writeString((*_iter123));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("values", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeBinary(this->values);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("timestamp", ::apache::thrift::protocol::T_I64, 5);
  xfer += oprot->writeI64(this->timestamp);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TSInsertRecordReq &a, TSInsertRecordReq &b) {
  using ::std::swap;
  swap(a.sessionId, b.sessionId);
  swap(a.deviceId, b.deviceId);
  swap(a.measurements, b.measurements);
  swap(a.values, b.values);
  swap(a.timestamp, b.timestamp);
}

TSInsertRecordReq::TSInsertRecordReq(const TSInsertRecordReq& other124) {
  sessionId = other124.sessionId;
  deviceId = other124.deviceId;
  measurements = other124.measurements;
  values = other124.values;
  timestamp = other124.timestamp;
}
TSInsertRecordReq& TSInsertRecordReq::operator=(const TSInsertRecordReq& other125) {
  sessionId = other125.sessionId;
  deviceId = other125.deviceId;
  measurements = other125.measurements;
  values = other125.values;
  timestamp = other125.timestamp;
  return *this;
}
void TSInsertRecordReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TSInsertRecordReq(";
  out << "sessionId=" << to_string(sessionId);
  out << ", " << "deviceId=" << to_string(deviceId);
  out << ", " << "measurements=" << to_string(measurements);
  out << ", " << "values=" << to_string(values);
  out << ", " << "timestamp=" << to_string(timestamp);
  out << ")";
}


TSInsertStringRecordReq::~TSInsertStringRecordReq() noexcept {
}


void TSInsertStringRecordReq::__set_sessionId(const int64_t val) {
  this->sessionId = val;
}

void TSInsertStringRecordReq::__set_deviceId(const std::string& val) {
  this->deviceId = val;
}

void TSInsertStringRecordReq::__set_measurements(const std::vector<std::string> & val) {
  this->measurements = val;
}

void TSInsertStringRecordReq::__set_values(const std::vector<std::string> & val) {
  this->values = val;
}

void TSInsertStringRecordReq::__set_timestamp(const int64_t val) {
  this->timestamp = val;
}
std::ostream& operator<<(std::ostream& out, const TSInsertStringRecordReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TSInsertStringRecordReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_sessionId = false;
  bool isset_deviceId = false;
  bool isset_measurements = false;
  bool isset_values = false;
  bool isset_timestamp = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->sessionId);
          isset_sessionId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->deviceId);
          isset_deviceId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->measurements.clear();
            uint32_t _size126;
            ::apache::thrift::protocol::TType _etype129;
            xfer += iprot->readListBegin(_etype129, _size126);
            this->measurements.resize(_size126);
            uint32_t _i130;
            for (_i130 = 0; _i130 < _size126; ++_i130)
            {
              xfer += iprot->readString(this->measurements[_i130]);
            }
            xfer += iprot->readListEnd();
          }
          isset_measurements = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->values.clear();
            uint32_t _size131;
            ::apache::thrift::protocol::TType _etype134;
            xfer += iprot->readListBegin(_etype134, _size131);
            this->values.resize(_size131);
            uint32_t _i135;
            for (_i135 = 0; _i135 < _size131; ++_i135)
            {
              xfer += iprot->readString(this->values[_i135]);
            }
            xfer += iprot->readListEnd();
          }
          isset_values = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->timestamp);
          isset_timestamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_sessionId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_deviceId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_measurements)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_values)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_timestamp)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TSInsertStringRecordReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TSInsertStringRecordReq");

  xfer += oprot->writeFieldBegin("sessionId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->sessionId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("deviceId", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->deviceId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("measurements", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->measurements.size()));
    std::vector<std::string> ::const_iterator _iter136;
    for (_iter136 = this->measurements.begin(); _iter136 != this->measurements.end(); ++_iter136)
    {
      xfer += oprot->writeString((*_iter136));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("values", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->values.size()));
    std::vector<std::string> ::const_iterator _iter137;
    for (_iter137 = this->values.begin(); _iter137 != this->values.end(); ++_iter137)
    {
      xfer += oprot->writeString((*_iter137));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("timestamp", ::apache::thrift::protocol::T_I64, 5);
  xfer += oprot->writeI64(this->timestamp);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TSInsertStringRecordReq &a, TSInsertStringRecordReq &b) {
  using ::std::swap;
  swap(a.sessionId, b.sessionId);
  swap(a.deviceId, b.deviceId);
  swap(a.measurements, b.measurements);
  swap(a.values, b.values);
  swap(a.timestamp, b.timestamp);
}

TSInsertStringRecordReq::TSInsertStringRecordReq(const TSInsertStringRecordReq& other138) {
  sessionId = other138.sessionId;
  deviceId = other138.deviceId;
  measurements = other138.measurements;
  values = other138.values;
  timestamp = other138.timestamp;
}
TSInsertStringRecordReq& TSInsertStringRecordReq::operator=(const TSInsertStringRecordReq& other139) {
  sessionId = other139.sessionId;
  deviceId = other139.deviceId;
  measurements = other139.measurements;
  values = other139.values;
  timestamp = other139.timestamp;
  return *this;
}
void TSInsertStringRecordReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TSInsertStringRecordReq(";
  out << "sessionId=" << to_string(sessionId);
  out << ", " << "deviceId=" << to_string(deviceId);
  out << ", " << "measurements=" << to_string(measurements);
  out << ", " << "values=" << to_string(values);
  out << ", " << "timestamp=" << to_string(timestamp);
  out << ")";
}


TSInsertTabletReq::~TSInsertTabletReq() noexcept {
}


void TSInsertTabletReq::__set_sessionId(const int64_t val) {
  this->sessionId = val;
}

void TSInsertTabletReq::__set_deviceId(const std::string& val) {
  this->deviceId = val;
}

void TSInsertTabletReq::__set_measurements(const std::vector<std::string> & val) {
  this->measurements = val;
}

void TSInsertTabletReq::__set_values(const std::string& val) {
  this->values = val;
}

void TSInsertTabletReq::__set_timestamps(const std::string& val) {
  this->timestamps = val;
}

void TSInsertTabletReq::__set_types(const std::vector<int32_t> & val) {
  this->types = val;
}

void TSInsertTabletReq::__set_size(const int32_t val) {
  this->size = val;
}
std::ostream& operator<<(std::ostream& out, const TSInsertTabletReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TSInsertTabletReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_sessionId = false;
  bool isset_deviceId = false;
  bool isset_measurements = false;
  bool isset_values = false;
  bool isset_timestamps = false;
  bool isset_types = false;
  bool isset_size = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->sessionId);
          isset_sessionId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->deviceId);
          isset_deviceId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->measurements.clear();
            uint32_t _size140;
            ::apache::thrift::protocol::TType _etype143;
            xfer += iprot->readListBegin(_etype143, _size140);
            this->measurements.resize(_size140);
            uint32_t _i144;
            for (_i144 = 0; _i144 < _size140; ++_i144)
            {
              xfer += iprot->readString(this->measurements[_i144]);
            }
            xfer += iprot->readListEnd();
          }
          isset_measurements = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->values);
          isset_values = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->timestamps);
          isset_timestamps = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->types.clear();
            uint32_t _size145;
            ::apache::thrift::protocol::TType _etype148;
            xfer += iprot->readListBegin(_etype148, _size145);
            this->types.resize(_size145);
            uint32_t _i149;
            for (_i149 = 0; _i149 < _size145; ++_i149)
            {
              xfer += iprot->readI32(this->types[_i149]);
            }
            xfer += iprot->readListEnd();
          }
          isset_types = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->size);
          isset_size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_sessionId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_deviceId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_measurements)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_values)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_timestamps)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_types)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_size)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TSInsertTabletReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TSInsertTabletReq");

  xfer += oprot->writeFieldBegin("sessionId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->sessionId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("deviceId", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->deviceId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("measurements", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->measurements.size()));
    std::vector<std::string> ::const_iterator _iter150;
    for (_iter150 = this->measurements.begin(); _iter150 != this->measurements.end(); ++_iter150)
    {
      xfer += oprot->writeString((*_iter150));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("values", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeBinary(this->values);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("timestamps", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeBinary(this->timestamps);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("types", ::apache::thrift::protocol::T_LIST, 6);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->types.size()));
    std::vector<int32_t> ::const_iterator _iter151;
    for (_iter151 = this->types.begin(); _iter151 != this->types.end(); ++_iter151)
    {
      xfer += oprot->writeI32((*_iter151));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("size", ::apache::thrift::protocol::T_I32, 7);
  xfer += oprot->writeI32(this->size);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TSInsertTabletReq &a, TSInsertTabletReq &b) {
  using ::std::swap;
  swap(a.sessionId, b.sessionId);
  swap(a.deviceId, b.deviceId);
  swap(a.measurements, b.measurements);
  swap(a.values, b.values);
  swap(a.timestamps, b.timestamps);
  swap(a.types, b.types);
  swap(a.size, b.size);
}

TSInsertTabletReq::TSInsertTabletReq(const TSInsertTabletReq& other152) {
  sessionId = other152.sessionId;
  deviceId = other152.deviceId;
  measurements = other152.measurements;
  values = other152.values;
  timestamps = other152.timestamps;
  types = other152.types;
  size = other152.size;
}
TSInsertTabletReq& TSInsertTabletReq::operator=(const TSInsertTabletReq& other153) {
  sessionId = other153.sessionId;
  deviceId = other153.deviceId;
  measurements = other153.measurements;
  values = other153.values;
  timestamps = other153.timestamps;
  types = other153.types;
  size = other153.size;
  return *this;
}
void TSInsertTabletReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TSInsertTabletReq(";
  out << "sessionId=" << to_string(sessionId);
  out << ", " << "deviceId=" << to_string(deviceId);
  out << ", " << "measurements=" << to_string(measurements);
  out << ", " << "values=" << to_string(values);
  out << ", " << "timestamps=" << to_string(timestamps);
  out << ", " << "types=" << to_string(types);
  out << ", " << "size=" << to_string(size);
  out << ")";
}


TSInsertTabletsReq::~TSInsertTabletsReq() noexcept {
}


void TSInsertTabletsReq::__set_sessionId(const int64_t val) {
  this->sessionId = val;
}

void TSInsertTabletsReq::__set_deviceIds(const std::vector<std::string> & val) {
  this->deviceIds = val;
}

void TSInsertTabletsReq::__set_measurementsList(const std::vector<std::vector<std::string> > & val) {
  this->measurementsList = val;
}

void TSInsertTabletsReq::__set_valuesList(const std::vector<std::string> & val) {
  this->valuesList = val;
}

void TSInsertTabletsReq::__set_timestampsList(const std::vector<std::string> & val) {
  this->timestampsList = val;
}

void TSInsertTabletsReq::__set_typesList(const std::vector<std::vector<int32_t> > & val) {
  this->typesList = val;
}

void TSInsertTabletsReq::__set_sizeList(const std::vector<int32_t> & val) {
  this->sizeList = val;
}
std::ostream& operator<<(std::ostream& out, const TSInsertTabletsReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TSInsertTabletsReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_sessionId = false;
  bool isset_deviceIds = false;
  bool isset_measurementsList = false;
  bool isset_valuesList = false;
  bool isset_timestampsList = false;
  bool isset_typesList = false;
  bool isset_sizeList = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->sessionId);
          isset_sessionId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->deviceIds.clear();
            uint32_t _size154;
            ::apache::thrift::protocol::TType _etype157;
            xfer += iprot->readListBegin(_etype157, _size154);
            this->deviceIds.resize(_size154);
            uint32_t _i158;
            for (_i158 = 0; _i158 < _size154; ++_i158)
            {
              xfer += iprot->readString(this->deviceIds[_i158]);
            }
            xfer += iprot->readListEnd();
          }
          isset_deviceIds = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->measurementsList.clear();
            uint32_t _size159;
            ::apache::thrift::protocol::TType _etype162;
            xfer += iprot->readListBegin(_etype162, _size159);
            this->measurementsList.resize(_size159);
            uint32_t _i163;
            for (_i163 = 0; _i163 < _size159; ++_i163)
            {
              {
                this->measurementsList[_i163].clear();
                uint32_t _size164;
                ::apache::thrift::protocol::TType _etype167;
                xfer += iprot->readListBegin(_etype167, _size164);
                this->measurementsList[_i163].resize(_size164);
                uint32_t _i168;
                for (_i168 = 0; _i168 < _size164; ++_i168)
                {
                  xfer += iprot->readString(this->measurementsList[_i163][_i168]);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readListEnd();
          }
          isset_measurementsList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->valuesList.clear();
            uint32_t _size169;
            ::apache::thrift::protocol::TType _etype172;
            xfer += iprot->readListBegin(_etype172, _size169);
            this->valuesList.resize(_size169);
            uint32_t _i173;
            for (_i173 = 0; _i173 < _size169; ++_i173)
            {
              xfer += iprot->readBinary(this->valuesList[_i173]);
            }
            xfer += iprot->readListEnd();
          }
          isset_valuesList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->timestampsList.clear();
            uint32_t _size174;
            ::apache::thrift::protocol::TType _etype177;
            xfer += iprot->readListBegin(_etype177, _size174);
            this->timestampsList.resize(_size174);
            uint32_t _i178;
            for (_i178 = 0; _i178 < _size174; ++_i178)
            {
              xfer += iprot->readBinary(this->timestampsList[_i178]);
            }
            xfer += iprot->readListEnd();
          }
          isset_timestampsList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->typesList.clear();
            uint32_t _size179;
            ::apache::thrift::protocol::TType _etype182;
            xfer += iprot->readListBegin(_etype182, _size179);
            this->typesList.resize(_size179);
            uint32_t _i183;
            for (_i183 = 0; _i183 < _size179; ++_i183)
            {
              {
                this->typesList[_i183].clear();
                uint32_t _size184;
                ::apache::thrift::protocol::TType _etype187;
                xfer += iprot->readListBegin(_etype187, _size184);
                this->typesList[_i183].resize(_size184);
                uint32_t _i188;
                for (_i188 = 0; _i188 < _size184; ++_i188)
                {
                  xfer += iprot->readI32(this->typesList[_i183][_i188]);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readListEnd();
          }
          isset_typesList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->sizeList.clear();
            uint32_t _size189;
            ::apache::thrift::protocol::TType _etype192;
            xfer += iprot->readListBegin(_etype192, _size189);
            this->sizeList.resize(_size189);
            uint32_t _i193;
            for (_i193 = 0; _i193 < _size189; ++_i193)
            {
              xfer += iprot->readI32(this->sizeList[_i193]);
            }
            xfer += iprot->readListEnd();
          }
          isset_sizeList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_sessionId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_deviceIds)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_measurementsList)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_valuesList)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_timestampsList)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_typesList)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_sizeList)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TSInsertTabletsReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TSInsertTabletsReq");

  xfer += oprot->writeFieldBegin("sessionId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->sessionId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("deviceIds", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->deviceIds.size()));
    std::vector<std::string> ::const_iterator _iter194;
    for (_iter194 = this->deviceIds.begin(); _iter194 != this->deviceIds.end(); ++_iter194)
    {
      xfer += oprot->writeString((*_iter194));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("measurementsList", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->measurementsList.size()));
    std::vector<std::vector<std::string> > ::const_iterator _iter195;
    for (_iter195 = this->measurementsList.begin(); _iter195 != this->measurementsList.end(); ++_iter195)
    {
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>((*_iter195).size()));
        std::vector<std::string> ::const_iterator _iter196;
        for (_iter196 = (*_iter195).begin(); _iter196 != (*_iter195).end(); ++_iter196)
        {
          xfer += oprot->writeString((*_iter196));
        }
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("valuesList", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->valuesList.size()));
    std::vector<std::string> ::const_iterator _iter197;
    for (_iter197 = this->valuesList.begin(); _iter197 != this->valuesList.end(); ++_iter197)
    {
      xfer += oprot->writeBinary((*_iter197));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("timestampsList", ::apache::thrift::protocol::T_LIST, 5);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->timestampsList.size()));
    std::vector<std::string> ::const_iterator _iter198;
    for (_iter198 = this->timestampsList.begin(); _iter198 != this->timestampsList.end(); ++_iter198)
    {
      xfer += oprot->writeBinary((*_iter198));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("typesList", ::apache::thrift::protocol::T_LIST, 6);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->typesList.size()));
    std::vector<std::vector<int32_t> > ::const_iterator _iter199;
    for (_iter199 = this->typesList.begin(); _iter199 != this->typesList.end(); ++_iter199)
    {
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>((*_iter199).size()));
        std::vector<int32_t> ::const_iterator _iter200;
        for (_iter200 = (*_iter199).begin(); _iter200 != (*_iter199).end(); ++_iter200)
        {
          xfer += oprot->writeI32((*_iter200));
        }
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sizeList", ::apache::thrift::protocol::T_LIST, 7);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->sizeList.size()));
    std::vector<int32_t> ::const_iterator _iter201;
    for (_iter201 = this->sizeList.begin(); _iter201 != this->sizeList.end(); ++_iter201)
    {
      xfer += oprot->writeI32((*_iter201));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TSInsertTabletsReq &a, TSInsertTabletsReq &b) {
  using ::std::swap;
  swap(a.sessionId, b.sessionId);
  swap(a.deviceIds, b.deviceIds);
  swap(a.measurementsList, b.measurementsList);
  swap(a.valuesList, b.valuesList);
  swap(a.timestampsList, b.timestampsList);
  swap(a.typesList, b.typesList);
  swap(a.sizeList, b.sizeList);
}

TSInsertTabletsReq::TSInsertTabletsReq(const TSInsertTabletsReq& other202) {
  sessionId = other202.sessionId;
  deviceIds = other202.deviceIds;
  measurementsList = other202.measurementsList;
  valuesList = other202.valuesList;
  timestampsList = other202.timestampsList;
  typesList = other202.typesList;
  sizeList = other202.sizeList;
}
TSInsertTabletsReq& TSInsertTabletsReq::operator=(const TSInsertTabletsReq& other203) {
  sessionId = other203.sessionId;
  deviceIds = other203.deviceIds;
  measurementsList = other203.measurementsList;
  valuesList = other203.valuesList;
  timestampsList = other203.timestampsList;
  typesList = other203.typesList;
  sizeList = other203.sizeList;
  return *this;
}
void TSInsertTabletsReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TSInsertTabletsReq(";
  out << "sessionId=" << to_string(sessionId);
  out << ", " << "deviceIds=" << to_string(deviceIds);
  out << ", " << "measurementsList=" << to_string(measurementsList);
  out << ", " << "valuesList=" << to_string(valuesList);
  out << ", " << "timestampsList=" << to_string(timestampsList);
  out << ", " << "typesList=" << to_string(typesList);
  out << ", " << "sizeList=" << to_string(sizeList);
  out << ")";
}


TSInsertRecordsReq::~TSInsertRecordsReq() noexcept {
}


void TSInsertRecordsReq::__set_sessionId(const int64_t val) {
  this->sessionId = val;
}

void TSInsertRecordsReq::__set_deviceIds(const std::vector<std::string> & val) {
  this->deviceIds = val;
}

void TSInsertRecordsReq::__set_measurementsList(const std::vector<std::vector<std::string> > & val) {
  this->measurementsList = val;
}

void TSInsertRecordsReq::__set_valuesList(const std::vector<std::string> & val) {
  this->valuesList = val;
}

void TSInsertRecordsReq::__set_timestamps(const std::vector<int64_t> & val) {
  this->timestamps = val;
}
std::ostream& operator<<(std::ostream& out, const TSInsertRecordsReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TSInsertRecordsReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_sessionId = false;
  bool isset_deviceIds = false;
  bool isset_measurementsList = false;
  bool isset_valuesList = false;
  bool isset_timestamps = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->sessionId);
          isset_sessionId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->deviceIds.clear();
            uint32_t _size204;
            ::apache::thrift::protocol::TType _etype207;
            xfer += iprot->readListBegin(_etype207, _size204);
            this->deviceIds.resize(_size204);
            uint32_t _i208;
            for (_i208 = 0; _i208 < _size204; ++_i208)
            {
              xfer += iprot->readString(this->deviceIds[_i208]);
            }
            xfer += iprot->readListEnd();
          }
          isset_deviceIds = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->measurementsList.clear();
            uint32_t _size209;
            ::apache::thrift::protocol::TType _etype212;
            xfer += iprot->readListBegin(_etype212, _size209);
            this->measurementsList.resize(_size209);
            uint32_t _i213;
            for (_i213 = 0; _i213 < _size209; ++_i213)
            {
              {
                this->measurementsList[_i213].clear();
                uint32_t _size214;
                ::apache::thrift::protocol::TType _etype217;
                xfer += iprot->readListBegin(_etype217, _size214);
                this->measurementsList[_i213].resize(_size214);
                uint32_t _i218;
                for (_i218 = 0; _i218 < _size214; ++_i218)
                {
                  xfer += iprot->readString(this->measurementsList[_i213][_i218]);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readListEnd();
          }
          isset_measurementsList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->valuesList.clear();
            uint32_t _size219;
            ::apache::thrift::protocol::TType _etype222;
            xfer += iprot->readListBegin(_etype222, _size219);
            this->valuesList.resize(_size219);
            uint32_t _i223;
            for (_i223 = 0; _i223 < _size219; ++_i223)
            {
              xfer += iprot->readBinary(this->valuesList[_i223]);
            }
            xfer += iprot->readListEnd();
          }
          isset_valuesList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->timestamps.clear();
            uint32_t _size224;
            ::apache::thrift::protocol::TType _etype227;
            xfer += iprot->readListBegin(_etype227, _size224);
            this->timestamps.resize(_size224);
            uint32_t _i228;
            for (_i228 = 0; _i228 < _size224; ++_i228)
            {
              xfer += iprot->readI64(this->timestamps[_i228]);
            }
            xfer += iprot->readListEnd();
          }
          isset_timestamps = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_sessionId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_deviceIds)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_measurementsList)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_valuesList)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_timestamps)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TSInsertRecordsReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TSInsertRecordsReq");

  xfer += oprot->writeFieldBegin("sessionId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->sessionId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("deviceIds", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->deviceIds.size()));
    std::vector<std::string> ::const_iterator _iter229;
    for (_iter229 = this->deviceIds.begin(); _iter229 != this->deviceIds.end(); ++_iter229)
    {
      xfer += oprot->writeString((*_iter229));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("measurementsList", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->measurementsList.size()));
    std::vector<std::vector<std::string> > ::const_iterator _iter230;
    for (_iter230 = this->measurementsList.begin(); _iter230 != this->measurementsList.end(); ++_iter230)
    {
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>((*_iter230).size()));
        std::vector<std::string> ::const_iterator _iter231;
        for (_iter231 = (*_iter230).begin(); _iter231 != (*_iter230).end(); ++_iter231)
        {
          xfer += oprot->writeString((*_iter231));
        }
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("valuesList", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->valuesList.size()));
    std::vector<std::string> ::const_iterator _iter232;
    for (_iter232 = this->valuesList.begin(); _iter232 != this->valuesList.end(); ++_iter232)
    {
      xfer += oprot->writeBinary((*_iter232));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("timestamps", ::apache::thrift::protocol::T_LIST, 5);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->timestamps.size()));
    std::vector<int64_t> ::const_iterator _iter233;
    for (_iter233 = this->timestamps.begin(); _iter233 != this->timestamps.end(); ++_iter233)
    {
      xfer += oprot->writeI64((*_iter233));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TSInsertRecordsReq &a, TSInsertRecordsReq &b) {
  using ::std::swap;
  swap(a.sessionId, b.sessionId);
  swap(a.deviceIds, b.deviceIds);
  swap(a.measurementsList, b.measurementsList);
  swap(a.valuesList, b.valuesList);
  swap(a.timestamps, b.timestamps);
}

TSInsertRecordsReq::TSInsertRecordsReq(const TSInsertRecordsReq& other234) {
  sessionId = other234.sessionId;
  deviceIds = other234.deviceIds;
  measurementsList = other234.measurementsList;
  valuesList = other234.valuesList;
  timestamps = other234.timestamps;
}
TSInsertRecordsReq& TSInsertRecordsReq::operator=(const TSInsertRecordsReq& other235) {
  sessionId = other235.sessionId;
  deviceIds = other235.deviceIds;
  measurementsList = other235.measurementsList;
  valuesList = other235.valuesList;
  timestamps = other235.timestamps;
  return *this;
}
void TSInsertRecordsReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TSInsertRecordsReq(";
  out << "sessionId=" << to_string(sessionId);
  out << ", " << "deviceIds=" << to_string(deviceIds);
  out << ", " << "measurementsList=" << to_string(measurementsList);
  out << ", " << "valuesList=" << to_string(valuesList);
  out << ", " << "timestamps=" << to_string(timestamps);
  out << ")";
}


TSInsertRecordsOfOneDeviceReq::~TSInsertRecordsOfOneDeviceReq() noexcept {
}


void TSInsertRecordsOfOneDeviceReq::__set_sessionId(const int64_t val) {
  this->sessionId = val;
}

void TSInsertRecordsOfOneDeviceReq::__set_deviceId(const std::string& val) {
  this->deviceId = val;
}

void TSInsertRecordsOfOneDeviceReq::__set_measurementsList(const std::vector<std::vector<std::string> > & val) {
  this->measurementsList = val;
}

void TSInsertRecordsOfOneDeviceReq::__set_valuesList(const std::vector<std::string> & val) {
  this->valuesList = val;
}

void TSInsertRecordsOfOneDeviceReq::__set_timestamps(const std::vector<int64_t> & val) {
  this->timestamps = val;
}
std::ostream& operator<<(std::ostream& out, const TSInsertRecordsOfOneDeviceReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TSInsertRecordsOfOneDeviceReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_sessionId = false;
  bool isset_deviceId = false;
  bool isset_measurementsList = false;
  bool isset_valuesList = false;
  bool isset_timestamps = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->sessionId);
          isset_sessionId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->deviceId);
          isset_deviceId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->measurementsList.clear();
            uint32_t _size236;
            ::apache::thrift::protocol::TType _etype239;
            xfer += iprot->readListBegin(_etype239, _size236);
            this->measurementsList.resize(_size236);
            uint32_t _i240;
            for (_i240 = 0; _i240 < _size236; ++_i240)
            {
              {
                this->measurementsList[_i240].clear();
                uint32_t _size241;
                ::apache::thrift::protocol::TType _etype244;
                xfer += iprot->readListBegin(_etype244, _size241);
                this->measurementsList[_i240].resize(_size241);
                uint32_t _i245;
                for (_i245 = 0; _i245 < _size241; ++_i245)
                {
                  xfer += iprot->readString(this->measurementsList[_i240][_i245]);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readListEnd();
          }
          isset_measurementsList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->valuesList.clear();
            uint32_t _size246;
            ::apache::thrift::protocol::TType _etype249;
            xfer += iprot->readListBegin(_etype249, _size246);
            this->valuesList.resize(_size246);
            uint32_t _i250;
            for (_i250 = 0; _i250 < _size246; ++_i250)
            {
              xfer += iprot->readBinary(this->valuesList[_i250]);
            }
            xfer += iprot->readListEnd();
          }
          isset_valuesList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->timestamps.clear();
            uint32_t _size251;
            ::apache::thrift::protocol::TType _etype254;
            xfer += iprot->readListBegin(_etype254, _size251);
            this->timestamps.resize(_size251);
            uint32_t _i255;
            for (_i255 = 0; _i255 < _size251; ++_i255)
            {
              xfer += iprot->readI64(this->timestamps[_i255]);
            }
            xfer += iprot->readListEnd();
          }
          isset_timestamps = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_sessionId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_deviceId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_measurementsList)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_valuesList)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_timestamps)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TSInsertRecordsOfOneDeviceReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TSInsertRecordsOfOneDeviceReq");

  xfer += oprot->writeFieldBegin("sessionId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->sessionId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("deviceId", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->deviceId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("measurementsList", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->measurementsList.size()));
    std::vector<std::vector<std::string> > ::const_iterator _iter256;
    for (_iter256 = this->measurementsList.begin(); _iter256 != this->measurementsList.end(); ++_iter256)
    {
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>((*_iter256).size()));
        std::vector<std::string> ::const_iterator _iter257;
        for (_iter257 = (*_iter256).begin(); _iter257 != (*_iter256).end(); ++_iter257)
        {
          xfer += oprot->writeString((*_iter257));
        }
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("valuesList", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->valuesList.size()));
    std::vector<std::string> ::const_iterator _iter258;
    for (_iter258 = this->valuesList.begin(); _iter258 != this->valuesList.end(); ++_iter258)
    {
      xfer += oprot->writeBinary((*_iter258));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("timestamps", ::apache::thrift::protocol::T_LIST, 5);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->timestamps.size()));
    std::vector<int64_t> ::const_iterator _iter259;
    for (_iter259 = this->timestamps.begin(); _iter259 != this->timestamps.end(); ++_iter259)
    {
      xfer += oprot->writeI64((*_iter259));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TSInsertRecordsOfOneDeviceReq &a, TSInsertRecordsOfOneDeviceReq &b) {
  using ::std::swap;
  swap(a.sessionId, b.sessionId);
  swap(a.deviceId, b.deviceId);
  swap(a.measurementsList, b.measurementsList);
  swap(a.valuesList, b.valuesList);
  swap(a.timestamps, b.timestamps);
}

TSInsertRecordsOfOneDeviceReq::TSInsertRecordsOfOneDeviceReq(const TSInsertRecordsOfOneDeviceReq& other260) {
  sessionId = other260.sessionId;
  deviceId = other260.deviceId;
  measurementsList = other260.measurementsList;
  valuesList = other260.valuesList;
  timestamps = other260.timestamps;
}
TSInsertRecordsOfOneDeviceReq& TSInsertRecordsOfOneDeviceReq::operator=(const TSInsertRecordsOfOneDeviceReq& other261) {
  sessionId = other261.sessionId;
  deviceId = other261.deviceId;
  measurementsList = other261.measurementsList;
  valuesList = other261.valuesList;
  timestamps = other261.timestamps;
  return *this;
}
void TSInsertRecordsOfOneDeviceReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TSInsertRecordsOfOneDeviceReq(";
  out << "sessionId=" << to_string(sessionId);
  out << ", " << "deviceId=" << to_string(deviceId);
  out << ", " << "measurementsList=" << to_string(measurementsList);
  out << ", " << "valuesList=" << to_string(valuesList);
  out << ", " << "timestamps=" << to_string(timestamps);
  out << ")";
}


TSInsertStringRecordsReq::~TSInsertStringRecordsReq() noexcept {
}


void TSInsertStringRecordsReq::__set_sessionId(const int64_t val) {
  this->sessionId = val;
}

void TSInsertStringRecordsReq::__set_deviceIds(const std::vector<std::string> & val) {
  this->deviceIds = val;
}

void TSInsertStringRecordsReq::__set_measurementsList(const std::vector<std::vector<std::string> > & val) {
  this->measurementsList = val;
}

void TSInsertStringRecordsReq::__set_valuesList(const std::vector<std::vector<std::string> > & val) {
  this->valuesList = val;
}

void TSInsertStringRecordsReq::__set_timestamps(const std::vector<int64_t> & val) {
  this->timestamps = val;
}
std::ostream& operator<<(std::ostream& out, const TSInsertStringRecordsReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TSInsertStringRecordsReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_sessionId = false;
  bool isset_deviceIds = false;
  bool isset_measurementsList = false;
  bool isset_valuesList = false;
  bool isset_timestamps = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->sessionId);
          isset_sessionId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->deviceIds.clear();
            uint32_t _size262;
            ::apache::thrift::protocol::TType _etype265;
            xfer += iprot->readListBegin(_etype265, _size262);
            this->deviceIds.resize(_size262);
            uint32_t _i266;
            for (_i266 = 0; _i266 < _size262; ++_i266)
            {
              xfer += iprot->readString(this->deviceIds[_i266]);
            }
            xfer += iprot->readListEnd();
          }
          isset_deviceIds = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->measurementsList.clear();
            uint32_t _size267;
            ::apache::thrift::protocol::TType _etype270;
            xfer += iprot->readListBegin(_etype270, _size267);
            this->measurementsList.resize(_size267);
            uint32_t _i271;
            for (_i271 = 0; _i271 < _size267; ++_i271)
            {
              {
                this->measurementsList[_i271].clear();
                uint32_t _size272;
                ::apache::thrift::protocol::TType _etype275;
                xfer += iprot->readListBegin(_etype275, _size272);
                this->measurementsList[_i271].resize(_size272);
                uint32_t _i276;
                for (_i276 = 0; _i276 < _size272; ++_i276)
                {
                  xfer += iprot->readString(this->measurementsList[_i271][_i276]);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readListEnd();
          }
          isset_measurementsList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->valuesList.clear();
            uint32_t _size277;
            ::apache::thrift::protocol::TType _etype280;
            xfer += iprot->readListBegin(_etype280, _size277);
            this->valuesList.resize(_size277);
            uint32_t _i281;
            for (_i281 = 0; _i281 < _size277; ++_i281)
            {
              {
                this->valuesList[_i281].clear();
                uint32_t _size282;
                ::apache::thrift::protocol::TType _etype285;
                xfer += iprot->readListBegin(_etype285, _size282);
                this->valuesList[_i281].resize(_size282);
                uint32_t _i286;
                for (_i286 = 0; _i286 < _size282; ++_i286)
                {
                  xfer += iprot->readString(this->valuesList[_i281][_i286]);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readListEnd();
          }
          isset_valuesList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->timestamps.clear();
            uint32_t _size287;
            ::apache::thrift::protocol::TType _etype290;
            xfer += iprot->readListBegin(_etype290, _size287);
            this->timestamps.resize(_size287);
            uint32_t _i291;
            for (_i291 = 0; _i291 < _size287; ++_i291)
            {
              xfer += iprot->readI64(this->timestamps[_i291]);
            }
            xfer += iprot->readListEnd();
          }
          isset_timestamps = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_sessionId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_deviceIds)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_measurementsList)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_valuesList)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_timestamps)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TSInsertStringRecordsReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TSInsertStringRecordsReq");

  xfer += oprot->writeFieldBegin("sessionId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->sessionId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("deviceIds", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->deviceIds.size()));
    std::vector<std::string> ::const_iterator _iter292;
    for (_iter292 = this->deviceIds.begin(); _iter292 != this->deviceIds.end(); ++_iter292)
    {
      xfer += oprot->writeString((*_iter292));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("measurementsList", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->measurementsList.size()));
    std::vector<std::vector<std::string> > ::const_iterator _iter293;
    for (_iter293 = this->measurementsList.begin(); _iter293 != this->measurementsList.end(); ++_iter293)
    {
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>((*_iter293).size()));
        std::vector<std::string> ::const_iterator _iter294;
        for (_iter294 = (*_iter293).begin(); _iter294 != (*_iter293).end(); ++_iter294)
        {
          xfer += oprot->writeString((*_iter294));
        }
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("valuesList", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->valuesList.size()));
    std::vector<std::vector<std::string> > ::const_iterator _iter295;
    for (_iter295 = this->valuesList.begin(); _iter295 != this->valuesList.end(); ++_iter295)
    {
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>((*_iter295).size()));
        std::vector<std::string> ::const_iterator _iter296;
        for (_iter296 = (*_iter295).begin(); _iter296 != (*_iter295).end(); ++_iter296)
        {
          xfer += oprot->writeString((*_iter296));
        }
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("timestamps", ::apache::thrift::protocol::T_LIST, 5);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->timestamps.size()));
    std::vector<int64_t> ::const_iterator _iter297;
    for (_iter297 = this->timestamps.begin(); _iter297 != this->timestamps.end(); ++_iter297)
    {
      xfer += oprot->writeI64((*_iter297));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TSInsertStringRecordsReq &a, TSInsertStringRecordsReq &b) {
  using ::std::swap;
  swap(a.sessionId, b.sessionId);
  swap(a.deviceIds, b.deviceIds);
  swap(a.measurementsList, b.measurementsList);
  swap(a.valuesList, b.valuesList);
  swap(a.timestamps, b.timestamps);
}

TSInsertStringRecordsReq::TSInsertStringRecordsReq(const TSInsertStringRecordsReq& other298) {
  sessionId = other298.sessionId;
  deviceIds = other298.deviceIds;
  measurementsList = other298.measurementsList;
  valuesList = other298.valuesList;
  timestamps = other298.timestamps;
}
TSInsertStringRecordsReq& TSInsertStringRecordsReq::operator=(const TSInsertStringRecordsReq& other299) {
  sessionId = other299.sessionId;
  deviceIds = other299.deviceIds;
  measurementsList = other299.measurementsList;
  valuesList = other299.valuesList;
  timestamps = other299.timestamps;
  return *this;
}
void TSInsertStringRecordsReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TSInsertStringRecordsReq(";
  out << "sessionId=" << to_string(sessionId);
  out << ", " << "deviceIds=" << to_string(deviceIds);
  out << ", " << "measurementsList=" << to_string(measurementsList);
  out << ", " << "valuesList=" << to_string(valuesList);
  out << ", " << "timestamps=" << to_string(timestamps);
  out << ")";
}


TSDeleteDataReq::~TSDeleteDataReq() noexcept {
}


void TSDeleteDataReq::__set_sessionId(const int64_t val) {
  this->sessionId = val;
}

void TSDeleteDataReq::__set_paths(const std::vector<std::string> & val) {
  this->paths = val;
}

void TSDeleteDataReq::__set_startTime(const int64_t val) {
  this->startTime = val;
}

void TSDeleteDataReq::__set_endTime(const int64_t val) {
  this->endTime = val;
}
std::ostream& operator<<(std::ostream& out, const TSDeleteDataReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TSDeleteDataReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_sessionId = false;
  bool isset_paths = false;
  bool isset_startTime = false;
  bool isset_endTime = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->sessionId);
          isset_sessionId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->paths.clear();
            uint32_t _size300;
            ::apache::thrift::protocol::TType _etype303;
            xfer += iprot->readListBegin(_etype303, _size300);
            this->paths.resize(_size300);
            uint32_t _i304;
            for (_i304 = 0; _i304 < _size300; ++_i304)
            {
              xfer += iprot->readString(this->paths[_i304]);
            }
            xfer += iprot->readListEnd();
          }
          isset_paths = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->startTime);
          isset_startTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->endTime);
          isset_endTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_sessionId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_paths)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_startTime)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_endTime)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TSDeleteDataReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TSDeleteDataReq");

  xfer += oprot->writeFieldBegin("sessionId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->sessionId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("paths", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->paths.size()));
    std::vector<std::string> ::const_iterator _iter305;
    for (_iter305 = this->paths.begin(); _iter305 != this->paths.end(); ++_iter305)
    {
      xfer += oprot->writeString((*_iter305));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("startTime", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->startTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("endTime", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->endTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TSDeleteDataReq &a, TSDeleteDataReq &b) {
  using ::std::swap;
  swap(a.sessionId, b.sessionId);
  swap(a.paths, b.paths);
  swap(a.startTime, b.startTime);
  swap(a.endTime, b.endTime);
}

TSDeleteDataReq::TSDeleteDataReq(const TSDeleteDataReq& other306) {
  sessionId = other306.sessionId;
  paths = other306.paths;
  startTime = other306.startTime;
  endTime = other306.endTime;
}
TSDeleteDataReq& TSDeleteDataReq::operator=(const TSDeleteDataReq& other307) {
  sessionId = other307.sessionId;
  paths = other307.paths;
  startTime = other307.startTime;
  endTime = other307.endTime;
  return *this;
}
void TSDeleteDataReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TSDeleteDataReq(";
  out << "sessionId=" << to_string(sessionId);
  out << ", " << "paths=" << to_string(paths);
  out << ", " << "startTime=" << to_string(startTime);
  out << ", " << "endTime=" << to_string(endTime);
  out << ")";
}


TSCreateTimeseriesReq::~TSCreateTimeseriesReq() noexcept {
}


void TSCreateTimeseriesReq::__set_sessionId(const int64_t val) {
  this->sessionId = val;
}

void TSCreateTimeseriesReq::__set_path(const std::string& val) {
  this->path = val;
}

void TSCreateTimeseriesReq::__set_dataType(const int32_t val) {
  this->dataType = val;
}

void TSCreateTimeseriesReq::__set_encoding(const int32_t val) {
  this->encoding = val;
}

void TSCreateTimeseriesReq::__set_compressor(const int32_t val) {
  this->compressor = val;
}

void TSCreateTimeseriesReq::__set_props(const std::map<std::string, std::string> & val) {
  this->props = val;
__isset.props = true;
}

void TSCreateTimeseriesReq::__set_tags(const std::map<std::string, std::string> & val) {
  this->tags = val;
__isset.tags = true;
}

void TSCreateTimeseriesReq::__set_attributes(const std::map<std::string, std::string> & val) {
  this->attributes = val;
__isset.attributes = true;
}

void TSCreateTimeseriesReq::__set_measurementAlias(const std::string& val) {
  this->measurementAlias = val;
__isset.measurementAlias = true;
}
std::ostream& operator<<(std::ostream& out, const TSCreateTimeseriesReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TSCreateTimeseriesReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_sessionId = false;
  bool isset_path = false;
  bool isset_dataType = false;
  bool isset_encoding = false;
  bool isset_compressor = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->sessionId);
          isset_sessionId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->path);
          isset_path = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->dataType);
          isset_dataType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->encoding);
          isset_encoding = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->compressor);
          isset_compressor = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->props.clear();
            uint32_t _size308;
            ::apache::thrift::protocol::TType _ktype309;
            ::apache::thrift::protocol::TType _vtype310;
            xfer += iprot->readMapBegin(_ktype309, _vtype310, _size308);
            uint32_t _i312;
            for (_i312 = 0; _i312 < _size308; ++_i312)
            {
              std::string _key313;
              xfer += iprot->readString(_key313);
              std::string& _val314 = this->props[_key313];
              xfer += iprot->readString(_val314);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.props = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->tags.clear();
            uint32_t _size315;
            ::apache::thrift::protocol::TType _ktype316;
            ::apache::thrift::protocol::TType _vtype317;
            xfer += iprot->readMapBegin(_ktype316, _vtype317, _size315);
            uint32_t _i319;
            for (_i319 = 0; _i319 < _size315; ++_i319)
            {
              std::string _key320;
              xfer += iprot->readString(_key320);
              std::string& _val321 = this->tags[_key320];
              xfer += iprot->readString(_val321);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.tags = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->attributes.clear();
            uint32_t _size322;
            ::apache::thrift::protocol::TType _ktype323;
            ::apache::thrift::protocol::TType _vtype324;
            xfer += iprot->readMapBegin(_ktype323, _vtype324, _size322);
            uint32_t _i326;
            for (_i326 = 0; _i326 < _size322; ++_i326)
            {
              std::string _key327;
              xfer += iprot->readString(_key327);
              std::string& _val328 = this->attributes[_key327];
              xfer += iprot->readString(_val328);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.attributes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->measurementAlias);
          this->__isset.measurementAlias = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_sessionId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_path)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_dataType)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_encoding)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_compressor)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TSCreateTimeseriesReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TSCreateTimeseriesReq");

  xfer += oprot->writeFieldBegin("sessionId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->sessionId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("path", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->path);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dataType", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->dataType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("encoding", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->encoding);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("compressor", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->compressor);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.props) {
    xfer += oprot->writeFieldBegin("props", ::apache::thrift::protocol::T_MAP, 6);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->props.size()));
      std::map<std::string, std::string> ::const_iterator _iter329;
      for (_iter329 = this->props.begin(); _iter329 != this->props.end(); ++_iter329)
      {
        xfer += oprot->writeString(_iter329->first);
        xfer += oprot->writeString(_iter329->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.tags) {
    xfer += oprot->writeFieldBegin("tags", ::apache::thrift::protocol::T_MAP, 7);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->tags.size()));
      std::map<std::string, std::string> ::const_iterator _iter330;
      for (_iter330 = this->tags.begin(); _iter330 != this->tags.end(); ++_iter330)
      {
        xfer += oprot->writeString(_iter330->first);
        xfer += oprot->writeString(_iter330->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.attributes) {
    xfer += oprot->writeFieldBegin("attributes", ::apache::thrift::protocol::T_MAP, 8);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->attributes.size()));
      std::map<std::string, std::string> ::const_iterator _iter331;
      for (_iter331 = this->attributes.begin(); _iter331 != this->attributes.end(); ++_iter331)
      {
        xfer += oprot->writeString(_iter331->first);
        xfer += oprot->writeString(_iter331->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.measurementAlias) {
    xfer += oprot->writeFieldBegin("measurementAlias", ::apache::thrift::protocol::T_STRING, 9);
    xfer += oprot->writeString(this->measurementAlias);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TSCreateTimeseriesReq &a, TSCreateTimeseriesReq &b) {
  using ::std::swap;
  swap(a.sessionId, b.sessionId);
  swap(a.path, b.path);
  swap(a.dataType, b.dataType);
  swap(a.encoding, b.encoding);
  swap(a.compressor, b.compressor);
  swap(a.props, b.props);
  swap(a.tags, b.tags);
  swap(a.attributes, b.attributes);
  swap(a.measurementAlias, b.measurementAlias);
  swap(a.__isset, b.__isset);
}

TSCreateTimeseriesReq::TSCreateTimeseriesReq(const TSCreateTimeseriesReq& other332) {
  sessionId = other332.sessionId;
  path = other332.path;
  dataType = other332.dataType;
  encoding = other332.encoding;
  compressor = other332.compressor;
  props = other332.props;
  tags = other332.tags;
  attributes = other332.attributes;
  measurementAlias = other332.measurementAlias;
  __isset = other332.__isset;
}
TSCreateTimeseriesReq& TSCreateTimeseriesReq::operator=(const TSCreateTimeseriesReq& other333) {
  sessionId = other333.sessionId;
  path = other333.path;
  dataType = other333.dataType;
  encoding = other333.encoding;
  compressor = other333.compressor;
  props = other333.props;
  tags = other333.tags;
  attributes = other333.attributes;
  measurementAlias = other333.measurementAlias;
  __isset = other333.__isset;
  return *this;
}
void TSCreateTimeseriesReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TSCreateTimeseriesReq(";
  out << "sessionId=" << to_string(sessionId);
  out << ", " << "path=" << to_string(path);
  out << ", " << "dataType=" << to_string(dataType);
  out << ", " << "encoding=" << to_string(encoding);
  out << ", " << "compressor=" << to_string(compressor);
  out << ", " << "props="; (__isset.props ? (out << to_string(props)) : (out << "<null>"));
  out << ", " << "tags="; (__isset.tags ? (out << to_string(tags)) : (out << "<null>"));
  out << ", " << "attributes="; (__isset.attributes ? (out << to_string(attributes)) : (out << "<null>"));
  out << ", " << "measurementAlias="; (__isset.measurementAlias ? (out << to_string(measurementAlias)) : (out << "<null>"));
  out << ")";
}


TSRawDataQueryReq::~TSRawDataQueryReq() noexcept {
}


void TSRawDataQueryReq::__set_sessionId(const int64_t val) {
  this->sessionId = val;
}

void TSRawDataQueryReq::__set_paths(const std::vector<std::string> & val) {
  this->paths = val;
}

void TSRawDataQueryReq::__set_fetchSize(const int32_t val) {
  this->fetchSize = val;
__isset.fetchSize = true;
}

void TSRawDataQueryReq::__set_startTime(const int64_t val) {
  this->startTime = val;
}

void TSRawDataQueryReq::__set_endTime(const int64_t val) {
  this->endTime = val;
}

void TSRawDataQueryReq::__set_statementId(const int64_t val) {
  this->statementId = val;
}

void TSRawDataQueryReq::__set_enableRedirectQuery(const bool val) {
  this->enableRedirectQuery = val;
__isset.enableRedirectQuery = true;
}
std::ostream& operator<<(std::ostream& out, const TSRawDataQueryReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TSRawDataQueryReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_sessionId = false;
  bool isset_paths = false;
  bool isset_startTime = false;
  bool isset_endTime = false;
  bool isset_statementId = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->sessionId);
          isset_sessionId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->paths.clear();
            uint32_t _size334;
            ::apache::thrift::protocol::TType _etype337;
            xfer += iprot->readListBegin(_etype337, _size334);
            this->paths.resize(_size334);
            uint32_t _i338;
            for (_i338 = 0; _i338 < _size334; ++_i338)
            {
              xfer += iprot->readString(this->paths[_i338]);
            }
            xfer += iprot->readListEnd();
          }
          isset_paths = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->fetchSize);
          this->__isset.fetchSize = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->startTime);
          isset_startTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->endTime);
          isset_endTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->statementId);
          isset_statementId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->enableRedirectQuery);
          this->__isset.enableRedirectQuery = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_sessionId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_paths)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_startTime)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_endTime)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_statementId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TSRawDataQueryReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TSRawDataQueryReq");

  xfer += oprot->writeFieldBegin("sessionId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->sessionId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("paths", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->paths.size()));
    std::vector<std::string> ::const_iterator _iter339;
    for (_iter339 = this->paths.begin(); _iter339 != this->paths.end(); ++_iter339)
    {
      xfer += oprot->writeString((*_iter339));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.fetchSize) {
    xfer += oprot->writeFieldBegin("fetchSize", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32(this->fetchSize);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("startTime", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->startTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("endTime", ::apache::thrift::protocol::T_I64, 5);
  xfer += oprot->writeI64(this->endTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("statementId", ::apache::thrift::protocol::T_I64, 6);
  xfer += oprot->writeI64(this->statementId);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.enableRedirectQuery) {
    xfer += oprot->writeFieldBegin("enableRedirectQuery", ::apache::thrift::protocol::T_BOOL, 7);
    xfer += oprot->writeBool(this->enableRedirectQuery);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TSRawDataQueryReq &a, TSRawDataQueryReq &b) {
  using ::std::swap;
  swap(a.sessionId, b.sessionId);
  swap(a.paths, b.paths);
  swap(a.fetchSize, b.fetchSize);
  swap(a.startTime, b.startTime);
  swap(a.endTime, b.endTime);
  swap(a.statementId, b.statementId);
  swap(a.enableRedirectQuery, b.enableRedirectQuery);
  swap(a.__isset, b.__isset);
}

TSRawDataQueryReq::TSRawDataQueryReq(const TSRawDataQueryReq& other340) {
  sessionId = other340.sessionId;
  paths = other340.paths;
  fetchSize = other340.fetchSize;
  startTime = other340.startTime;
  endTime = other340.endTime;
  statementId = other340.statementId;
  enableRedirectQuery = other340.enableRedirectQuery;
  __isset = other340.__isset;
}
TSRawDataQueryReq& TSRawDataQueryReq::operator=(const TSRawDataQueryReq& other341) {
  sessionId = other341.sessionId;
  paths = other341.paths;
  fetchSize = other341.fetchSize;
  startTime = other341.startTime;
  endTime = other341.endTime;
  statementId = other341.statementId;
  enableRedirectQuery = other341.enableRedirectQuery;
  __isset = other341.__isset;
  return *this;
}
void TSRawDataQueryReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TSRawDataQueryReq(";
  out << "sessionId=" << to_string(sessionId);
  out << ", " << "paths=" << to_string(paths);
  out << ", " << "fetchSize="; (__isset.fetchSize ? (out << to_string(fetchSize)) : (out << "<null>"));
  out << ", " << "startTime=" << to_string(startTime);
  out << ", " << "endTime=" << to_string(endTime);
  out << ", " << "statementId=" << to_string(statementId);
  out << ", " << "enableRedirectQuery="; (__isset.enableRedirectQuery ? (out << to_string(enableRedirectQuery)) : (out << "<null>"));
  out << ")";
}


TSCreateMultiTimeseriesReq::~TSCreateMultiTimeseriesReq() noexcept {
}


void TSCreateMultiTimeseriesReq::__set_sessionId(const int64_t val) {
  this->sessionId = val;
}

void TSCreateMultiTimeseriesReq::__set_paths(const std::vector<std::string> & val) {
  this->paths = val;
}

void TSCreateMultiTimeseriesReq::__set_dataTypes(const std::vector<int32_t> & val) {
  this->dataTypes = val;
}

void TSCreateMultiTimeseriesReq::__set_encodings(const std::vector<int32_t> & val) {
  this->encodings = val;
}

void TSCreateMultiTimeseriesReq::__set_compressors(const std::vector<int32_t> & val) {
  this->compressors = val;
}

void TSCreateMultiTimeseriesReq::__set_propsList(const std::vector<std::map<std::string, std::string> > & val) {
  this->propsList = val;
__isset.propsList = true;
}

void TSCreateMultiTimeseriesReq::__set_tagsList(const std::vector<std::map<std::string, std::string> > & val) {
  this->tagsList = val;
__isset.tagsList = true;
}

void TSCreateMultiTimeseriesReq::__set_attributesList(const std::vector<std::map<std::string, std::string> > & val) {
  this->attributesList = val;
__isset.attributesList = true;
}

void TSCreateMultiTimeseriesReq::__set_measurementAliasList(const std::vector<std::string> & val) {
  this->measurementAliasList = val;
__isset.measurementAliasList = true;
}
std::ostream& operator<<(std::ostream& out, const TSCreateMultiTimeseriesReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TSCreateMultiTimeseriesReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_sessionId = false;
  bool isset_paths = false;
  bool isset_dataTypes = false;
  bool isset_encodings = false;
  bool isset_compressors = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->sessionId);
          isset_sessionId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->paths.clear();
            uint32_t _size342;
            ::apache::thrift::protocol::TType _etype345;
            xfer += iprot->readListBegin(_etype345, _size342);
            this->paths.resize(_size342);
            uint32_t _i346;
            for (_i346 = 0; _i346 < _size342; ++_i346)
            {
              xfer += iprot->readString(this->paths[_i346]);
            }
            xfer += iprot->readListEnd();
          }
          isset_paths = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->dataTypes.clear();
            uint32_t _size347;
            ::apache::thrift::protocol::TType _etype350;
            xfer += iprot->readListBegin(_etype350, _size347);
            this->dataTypes.resize(_size347);
            uint32_t _i351;
            for (_i351 = 0; _i351 < _size347; ++_i351)
            {
              xfer += iprot->readI32(this->dataTypes[_i351]);
            }
            xfer += iprot->readListEnd();
          }
          isset_dataTypes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->encodings.clear();
            uint32_t _size352;
            ::apache::thrift::protocol::TType _etype355;
            xfer += iprot->readListBegin(_etype355, _size352);
            this->encodings.resize(_size352);
            uint32_t _i356;
            for (_i356 = 0; _i356 < _size352; ++_i356)
            {
              xfer += iprot->readI32(this->encodings[_i356]);
            }
            xfer += iprot->readListEnd();
          }
          isset_encodings = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->compressors.clear();
            uint32_t _size357;
            ::apache::thrift::protocol::TType _etype360;
            xfer += iprot->readListBegin(_etype360, _size357);
            this->compressors.resize(_size357);
            uint32_t _i361;
            for (_i361 = 0; _i361 < _size357; ++_i361)
            {
              xfer += iprot->readI32(this->compressors[_i361]);
            }
            xfer += iprot->readListEnd();
          }
          isset_compressors = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->propsList.clear();
            uint32_t _size362;
            ::apache::thrift::protocol::TType _etype365;
            xfer += iprot->readListBegin(_etype365, _size362);
            this->propsList.resize(_size362);
            uint32_t _i366;
            for (_i366 = 0; _i366 < _size362; ++_i366)
            {
              {
                this->propsList[_i366].clear();
                uint32_t _size367;
                ::apache::thrift::protocol::TType _ktype368;
                ::apache::thrift::protocol::TType _vtype369;
                xfer += iprot->readMapBegin(_ktype368, _vtype369, _size367);
                uint32_t _i371;
                for (_i371 = 0; _i371 < _size367; ++_i371)
                {
                  std::string _key372;
                  xfer += iprot->readString(_key372);
                  std::string& _val373 = this->propsList[_i366][_key372];
                  xfer += iprot->readString(_val373);
                }
                xfer += iprot->readMapEnd();
              }
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.propsList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->tagsList.clear();
            uint32_t _size374;
            ::apache::thrift::protocol::TType _etype377;
            xfer += iprot->readListBegin(_etype377, _size374);
            this->tagsList.resize(_size374);
            uint32_t _i378;
            for (_i378 = 0; _i378 < _size374; ++_i378)
            {
              {
                this->tagsList[_i378].clear();
                uint32_t _size379;
                ::apache::thrift::protocol::TType _ktype380;
                ::apache::thrift::protocol::TType _vtype381;
                xfer += iprot->readMapBegin(_ktype380, _vtype381, _size379);
                uint32_t _i383;
                for (_i383 = 0; _i383 < _size379; ++_i383)
                {
                  std::string _key384;
                  xfer += iprot->readString(_key384);
                  std::string& _val385 = this->tagsList[_i378][_key384];
                  xfer += iprot->readString(_val385);
                }
                xfer += iprot->readMapEnd();
              }
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.tagsList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->attributesList.clear();
            uint32_t _size386;
            ::apache::thrift::protocol::TType _etype389;
            xfer += iprot->readListBegin(_etype389, _size386);
            this->attributesList.resize(_size386);
            uint32_t _i390;
            for (_i390 = 0; _i390 < _size386; ++_i390)
            {
              {
                this->attributesList[_i390].clear();
                uint32_t _size391;
                ::apache::thrift::protocol::TType _ktype392;
                ::apache::thrift::protocol::TType _vtype393;
                xfer += iprot->readMapBegin(_ktype392, _vtype393, _size391);
                uint32_t _i395;
                for (_i395 = 0; _i395 < _size391; ++_i395)
                {
                  std::string _key396;
                  xfer += iprot->readString(_key396);
                  std::string& _val397 = this->attributesList[_i390][_key396];
                  xfer += iprot->readString(_val397);
                }
                xfer += iprot->readMapEnd();
              }
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.attributesList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->measurementAliasList.clear();
            uint32_t _size398;
            ::apache::thrift::protocol::TType _etype401;
            xfer += iprot->readListBegin(_etype401, _size398);
            this->measurementAliasList.resize(_size398);
            uint32_t _i402;
            for (_i402 = 0; _i402 < _size398; ++_i402)
            {
              xfer += iprot->readString(this->measurementAliasList[_i402]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.measurementAliasList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_sessionId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_paths)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_dataTypes)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_encodings)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_compressors)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TSCreateMultiTimeseriesReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TSCreateMultiTimeseriesReq");

  xfer += oprot->writeFieldBegin("sessionId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->sessionId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("paths", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->paths.size()));
    std::vector<std::string> ::const_iterator _iter403;
    for (_iter403 = this->paths.begin(); _iter403 != this->paths.end(); ++_iter403)
    {
      xfer += oprot->writeString((*_iter403));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dataTypes", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->dataTypes.size()));
    std::vector<int32_t> ::const_iterator _iter404;
    for (_iter404 = this->dataTypes.begin(); _iter404 != this->dataTypes.end(); ++_iter404)
    {
      xfer += oprot->writeI32((*_iter404));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("encodings", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->encodings.size()));
    std::vector<int32_t> ::const_iterator _iter405;
    for (_iter405 = this->encodings.begin(); _iter405 != this->encodings.end(); ++_iter405)
    {
      xfer += oprot->writeI32((*_iter405));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("compressors", ::apache::thrift::protocol::T_LIST, 5);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->compressors.size()));
    std::vector<int32_t> ::const_iterator _iter406;
    for (_iter406 = this->compressors.begin(); _iter406 != this->compressors.end(); ++_iter406)
    {
      xfer += oprot->writeI32((*_iter406));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.propsList) {
    xfer += oprot->writeFieldBegin("propsList", ::apache::thrift::protocol::T_LIST, 6);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_MAP, static_cast<uint32_t>(this->propsList.size()));
      std::vector<std::map<std::string, std::string> > ::const_iterator _iter407;
      for (_iter407 = this->propsList.begin(); _iter407 != this->propsList.end(); ++_iter407)
      {
        {
          xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>((*_iter407).size()));
          std::map<std::string, std::string> ::const_iterator _iter408;
          for (_iter408 = (*_iter407).begin(); _iter408 != (*_iter407).end(); ++_iter408)
          {
            xfer += oprot->writeString(_iter408->first);
            xfer += oprot->writeString(_iter408->second);
          }
          xfer += oprot->writeMapEnd();
        }
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.tagsList) {
    xfer += oprot->writeFieldBegin("tagsList", ::apache::thrift::protocol::T_LIST, 7);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_MAP, static_cast<uint32_t>(this->tagsList.size()));
      std::vector<std::map<std::string, std::string> > ::const_iterator _iter409;
      for (_iter409 = this->tagsList.begin(); _iter409 != this->tagsList.end(); ++_iter409)
      {
        {
          xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>((*_iter409).size()));
          std::map<std::string, std::string> ::const_iterator _iter410;
          for (_iter410 = (*_iter409).begin(); _iter410 != (*_iter409).end(); ++_iter410)
          {
            xfer += oprot->writeString(_iter410->first);
            xfer += oprot->writeString(_iter410->second);
          }
          xfer += oprot->writeMapEnd();
        }
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.attributesList) {
    xfer += oprot->writeFieldBegin("attributesList", ::apache::thrift::protocol::T_LIST, 8);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_MAP, static_cast<uint32_t>(this->attributesList.size()));
      std::vector<std::map<std::string, std::string> > ::const_iterator _iter411;
      for (_iter411 = this->attributesList.begin(); _iter411 != this->attributesList.end(); ++_iter411)
      {
        {
          xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>((*_iter411).size()));
          std::map<std::string, std::string> ::const_iterator _iter412;
          for (_iter412 = (*_iter411).begin(); _iter412 != (*_iter411).end(); ++_iter412)
          {
            xfer += oprot->writeString(_iter412->first);
            xfer += oprot->writeString(_iter412->second);
          }
          xfer += oprot->writeMapEnd();
        }
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.measurementAliasList) {
    xfer += oprot->writeFieldBegin("measurementAliasList", ::apache::thrift::protocol::T_LIST, 9);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->measurementAliasList.size()));
      std::vector<std::string> ::const_iterator _iter413;
      for (_iter413 = this->measurementAliasList.begin(); _iter413 != this->measurementAliasList.end(); ++_iter413)
      {
        xfer += oprot->writeString((*_iter413));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TSCreateMultiTimeseriesReq &a, TSCreateMultiTimeseriesReq &b) {
  using ::std::swap;
  swap(a.sessionId, b.sessionId);
  swap(a.paths, b.paths);
  swap(a.dataTypes, b.dataTypes);
  swap(a.encodings, b.encodings);
  swap(a.compressors, b.compressors);
  swap(a.propsList, b.propsList);
  swap(a.tagsList, b.tagsList);
  swap(a.attributesList, b.attributesList);
  swap(a.measurementAliasList, b.measurementAliasList);
  swap(a.__isset, b.__isset);
}

TSCreateMultiTimeseriesReq::TSCreateMultiTimeseriesReq(const TSCreateMultiTimeseriesReq& other414) {
  sessionId = other414.sessionId;
  paths = other414.paths;
  dataTypes = other414.dataTypes;
  encodings = other414.encodings;
  compressors = other414.compressors;
  propsList = other414.propsList;
  tagsList = other414.tagsList;
  attributesList = other414.attributesList;
  measurementAliasList = other414.measurementAliasList;
  __isset = other414.__isset;
}
TSCreateMultiTimeseriesReq& TSCreateMultiTimeseriesReq::operator=(const TSCreateMultiTimeseriesReq& other415) {
  sessionId = other415.sessionId;
  paths = other415.paths;
  dataTypes = other415.dataTypes;
  encodings = other415.encodings;
  compressors = other415.compressors;
  propsList = other415.propsList;
  tagsList = other415.tagsList;
  attributesList = other415.attributesList;
  measurementAliasList = other415.measurementAliasList;
  __isset = other415.__isset;
  return *this;
}
void TSCreateMultiTimeseriesReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TSCreateMultiTimeseriesReq(";
  out << "sessionId=" << to_string(sessionId);
  out << ", " << "paths=" << to_string(paths);
  out << ", " << "dataTypes=" << to_string(dataTypes);
  out << ", " << "encodings=" << to_string(encodings);
  out << ", " << "compressors=" << to_string(compressors);
  out << ", " << "propsList="; (__isset.propsList ? (out << to_string(propsList)) : (out << "<null>"));
  out << ", " << "tagsList="; (__isset.tagsList ? (out << to_string(tagsList)) : (out << "<null>"));
  out << ", " << "attributesList="; (__isset.attributesList ? (out << to_string(attributesList)) : (out << "<null>"));
  out << ", " << "measurementAliasList="; (__isset.measurementAliasList ? (out << to_string(measurementAliasList)) : (out << "<null>"));
  out << ")";
}


ServerProperties::~ServerProperties() noexcept {
}


void ServerProperties::__set_version(const std::string& val) {
  this->version = val;
}

void ServerProperties::__set_supportedTimeAggregationOperations(const std::vector<std::string> & val) {
  this->supportedTimeAggregationOperations = val;
}

void ServerProperties::__set_timestampPrecision(const std::string& val) {
  this->timestampPrecision = val;
}
std::ostream& operator<<(std::ostream& out, const ServerProperties& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ServerProperties::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_version = false;
  bool isset_supportedTimeAggregationOperations = false;
  bool isset_timestampPrecision = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->version);
          isset_version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->supportedTimeAggregationOperations.clear();
            uint32_t _size416;
            ::apache::thrift::protocol::TType _etype419;
            xfer += iprot->readListBegin(_etype419, _size416);
            this->supportedTimeAggregationOperations.resize(_size416);
            uint32_t _i420;
            for (_i420 = 0; _i420 < _size416; ++_i420)
            {
              xfer += iprot->readString(this->supportedTimeAggregationOperations[_i420]);
            }
            xfer += iprot->readListEnd();
          }
          isset_supportedTimeAggregationOperations = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->timestampPrecision);
          isset_timestampPrecision = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_version)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_supportedTimeAggregationOperations)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_timestampPrecision)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ServerProperties::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ServerProperties");

  xfer += oprot->writeFieldBegin("version", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->version);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("supportedTimeAggregationOperations", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->supportedTimeAggregationOperations.size()));
    std::vector<std::string> ::const_iterator _iter421;
    for (_iter421 = this->supportedTimeAggregationOperations.begin(); _iter421 != this->supportedTimeAggregationOperations.end(); ++_iter421)
    {
      xfer += oprot->writeString((*_iter421));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("timestampPrecision", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->timestampPrecision);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ServerProperties &a, ServerProperties &b) {
  using ::std::swap;
  swap(a.version, b.version);
  swap(a.supportedTimeAggregationOperations, b.supportedTimeAggregationOperations);
  swap(a.timestampPrecision, b.timestampPrecision);
}

ServerProperties::ServerProperties(const ServerProperties& other422) {
  version = other422.version;
  supportedTimeAggregationOperations = other422.supportedTimeAggregationOperations;
  timestampPrecision = other422.timestampPrecision;
}
ServerProperties& ServerProperties::operator=(const ServerProperties& other423) {
  version = other423.version;
  supportedTimeAggregationOperations = other423.supportedTimeAggregationOperations;
  timestampPrecision = other423.timestampPrecision;
  return *this;
}
void ServerProperties::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ServerProperties(";
  out << "version=" << to_string(version);
  out << ", " << "supportedTimeAggregationOperations=" << to_string(supportedTimeAggregationOperations);
  out << ", " << "timestampPrecision=" << to_string(timestampPrecision);
  out << ")";
}


